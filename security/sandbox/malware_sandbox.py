"""Malware Analysis Sandbox."""

from __future__ import annotations

import json
import logging
import shutil
import subprocess
import tempfile
import time
from pathlib import Path

from security.sandbox.config import AnalysisResult, MalwareSandboxConfig, Threat

logger = logging.getLogger(__name__)


class MalwareSandbox:
    """Isolated container for malware analysis."""

    IMAGE_NAME = "nautilus-malware-sandbox"

    def __init__(self, config: MalwareSandboxConfig | None = None):
        """Initialize sandbox."""
        self.config = config or MalwareSandboxConfig()
        self._ensure_image_exists()

    def _ensure_image_exists(self) -> bool:
        """Check if Docker image exists."""
        try:
            result = subprocess.run(
                ["docker", "image", "inspect", self.IMAGE_NAME], capture_output=True, timeout=10
            )
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False

    def analyze_file(self, file_path: Path) -> AnalysisResult:
        """Analyze file in isolated container."""
        start_time = time.time()

        if not file_path.exists():
            return AnalysisResult(
                is_clean=False,
                threats=[
                    Threat(
                        type="file_not_found",
                        severity="error",
                        description=f"File not found: {file_path}",
                        confidence=1.0,
                    )
                ],
            )

        file_size = file_path.stat().st_size
        max_size = self.config.max_file_size_mb * 1024 * 1024
        if file_size > max_size:
            return AnalysisResult(
                is_clean=False,
                threats=[
                    Threat(
                        type="file_too_large",
                        severity="warning",
                        description=f"File exceeds limit: {file_size} > {max_size}",
                        confidence=1.0,
                    )
                ],
                file_size=file_size,
            )

        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            input_dir = temp_path / "input"
            output_dir = temp_path / "output"
            input_dir.mkdir()
            output_dir.mkdir()

            shutil.copy2(file_path, input_dir / file_path.name)
            result = self._run_container(input_dir, output_dir)
            analysis_result = self._parse_result(result, file_path)
            analysis_result.scan_duration_ms = int((time.time() - start_time) * 1000)
            analysis_result.file_size = file_size
            return analysis_result

    def analyze_code(self, code: str, language: str = "python") -> AnalysisResult:
        """Analyze code snippet."""
        start_time = time.time()
        suffix = {".py": ".py", "python": ".py", "javascript": ".js", "bash": ".sh"}.get(
            language, ".txt"
        )

        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            input_dir = temp_path / "input"
            output_dir = temp_path / "output"
            input_dir.mkdir()
            output_dir.mkdir()

            code_file = input_dir / f"code_snippet{suffix}"
            code_file.write_text(code)

            result = self._run_container(input_dir, output_dir)
            analysis_result = self._parse_result(result, code_file)
            analysis_result.scan_duration_ms = int((time.time() - start_time) * 1000)
            analysis_result.file_size = len(code)
            analysis_result.details["source"] = "code_snippet"
            return analysis_result

    def _run_container(self, input_dir: Path, output_dir: Path) -> subprocess.CompletedProcess:
        """Run analysis container."""
        cmd = [
            "docker",
            "run",
            "--rm",
            "--network",
            "none",
            "--read-only",
            "--security-opt",
            "no-new-privileges:true",
            "--cap-drop",
            "ALL",
            "--memory",
            self.config.memory_limit,
            "--cpus",
            str(self.config.cpu_limit),
            "--tmpfs",
            "/tmp:size=50M,mode=1777",
            "--tmpfs",
            "/analysis/output:size=100M,mode=1777",
            "-v",
            f"{input_dir}:/analysis/input:ro",
            "-e",
            f"ANALYSIS_TIMEOUT={self.config.timeout_seconds}",
            self.IMAGE_NAME,
        ]

        try:
            return subprocess.run(
                cmd, capture_output=True, text=True, timeout=self.config.timeout_seconds + 10
            )
        except subprocess.TimeoutExpired:
            return subprocess.CompletedProcess(
                cmd, returncode=-1, stdout="", stderr="Analysis timed out"
            )

    def _parse_result(self, result: subprocess.CompletedProcess, file_path: Path) -> AnalysisResult:
        """Parse container output."""
        if result.returncode == -1 and "timed out" in result.stderr:
            return AnalysisResult(
                is_clean=False,
                threats=[
                    Threat(
                        type="analysis_timeout",
                        severity="warning",
                        description="Analysis timed out",
                        location=str(file_path),
                        confidence=1.0,
                    )
                ],
            )

        try:
            data = json.loads(result.stdout)
            threats = [
                Threat(
                    type=t.get("type", "unknown"),
                    severity=t.get("severity", "medium"),
                    description=t.get("description", ""),
                    location=t.get("location", ""),
                    confidence=t.get("confidence", 0.5),
                )
                for t in data.get("threats", [])
            ]
            return AnalysisResult(
                is_clean=data.get("is_clean", True),
                threats=threats,
                file_hash=data.get("file_hash", ""),
                details=data.get("details", {}),
            )
        except json.JSONDecodeError:
            return AnalysisResult(
                is_clean=result.returncode == 0,
                threats=[
                    Threat(
                        type="parse_error",
                        severity="warning",
                        description=result.stderr or result.stdout,
                        location=str(file_path),
                        confidence=0.5,
                    )
                ]
                if result.returncode != 0
                else [],
            )

    def is_docker_available(self) -> bool:
        """Check Docker availability."""
        try:
            result = subprocess.run(["docker", "info"], capture_output=True, timeout=5)
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False
