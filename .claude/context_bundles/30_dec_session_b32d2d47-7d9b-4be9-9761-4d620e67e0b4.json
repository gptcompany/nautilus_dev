{
  "session_id": "b32d2d47-7d9b-4be9-9761-4d620e67e0b4",
  "created_at": "2025-12-30T19:33:53.201732",
  "operations": [
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:33:53.201747",
      "file_path": "/media/sam/1TB/nautilus_dev/specs/017-position-recovery/contracts/recovery_events.py"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:33:53.872110",
      "command": "ls -la /media/sam/1TB/nautilus_dev/tests/unit/recovery/ 2>/dev/null",
      "description": "List unit recovery tests"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:33:53.892723",
      "command": "ls -la /media/sam/1TB/nautilus_dev/tests/integration/recovery/ 2>/dev/null",
      "description": "List integration recovery tests"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:33:59.865432",
      "file_path": "/media/sam/1TB/nautilus_dev/tests/unit/recovery/test_position_loading.py"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:01.699792",
      "command": "grep -r \"request_bars\\|on_historical\\|request_\" /media/sam/1TB/nautilus_dev/docs/discord/ --include=\"*.md\" | head -20",
      "description": "Search Discord for request_bars pattern"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:01.722299",
      "command": "ls -la /media/sam/1TB/nautilus_dev/strategies/common/recovery/",
      "description": "Check existing recovery files"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:34:05.282596",
      "file_path": "/media/sam/1TB/nautilus_dev/tests/unit/recovery/test_reconciliation.py"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:34:08.410821",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/events.py"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:34:08.423412",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/provider.py"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:11.639792",
      "command": "find /media/sam/1TB/nautilus_dev/tests -name \"conftest.py\" | head -5",
      "description": "Find conftest files"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:17.466013",
      "command": "grep -r \"def on_bar\\|def on_historical\\|def request_bars\" /media/sam/1TB/nautilus_dev/strategies/ --include=\"*.py\" | head -20",
      "description": "Find bar handling patterns"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:17.477891",
      "command": "grep -r \"from nautilus_trader\" /media/sam/1TB/nautilus_dev/strategies/examples/risk_managed_strategy.py | head -20",
      "description": "Check imports pattern"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:18.971134",
      "command": "cat /media/sam/1TB/nautilus_dev/tests/unit/recovery/__init__.py 2>/dev/null || echo \"File not found\"",
      "description": "Check unit recovery init"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:20.403313",
      "command": "find /media/sam/1TB/nautilus_dev/tests -path \"*/unit/conftest.py\" 2>/dev/null | head -5",
      "description": "Find unit conftest"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:34:23.393719",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/examples/risk_managed_strategy.py"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:28.374933",
      "command": "ls -la /media/sam/1TB/nautilus_dev/tests/unit/ 2>/dev/null",
      "description": "Check unit test directory"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:30.918153",
      "command": "grep -rn \"request_bars\\|on_historical_data\\|request_aggregated_bars\" /media/sam/1TB/nautilus_dev/docs/discord/ --include=\"*.md\" -A 2 -B 2 | head -80",
      "description": "Search for bar request patterns in Discord"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:34.150598",
      "command": "cat /media/sam/1TB/nautilus_dev/tests/conftest.py 2>/dev/null | head -100",
      "description": "Check root conftest"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:34:42.036074",
      "todo_count": 8
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:43.599751",
      "command": "grep -r \"mock_cache\" /media/sam/1TB/nautilus_dev/tests/ --include=\"*.py\" | head -20",
      "description": "Search for mock_cache fixture"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:48.248752",
      "command": "grep -r \"OrderType\\|STOP_MARKET\\|STOP_LIMIT\" /media/sam/1TB/nautilus_dev/strategies/ --include=\"*.py\" | head -10",
      "description": "Find OrderType imports"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:34:51.461538",
      "file_path": "/media/sam/1TB/nautilus_dev/tests/integration/recovery/conftest.py"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:34:54.235313",
      "command": "grep -rn \"OrderType\" /media/sam/1TB/nautilus_dev/docs/discord/ --include=\"*.md\" | head -10",
      "description": "Find OrderType usage in Discord"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:35:00.323738",
      "command": "grep -rn \"from nautilus_trader.model.enums import\" /media/sam/1TB/nautilus_dev/strategies/ --include=\"*.py\" | head -10",
      "description": "Find enum imports"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:35:01.289561",
      "todo_count": 4
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:35:06.968398",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/provider.py"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:35:27.141523",
      "command": "ls -la /media/sam/1TB/nautilus_dev/strategies/common/recovery/",
      "description": "Check recovery module files"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:35:30.302541",
      "command": "cat > /media/sam/1TB/nautilus_dev/strategies/common/recovery/provider.py << 'EOF'\n\"\"\"Position Recovery Provider (Spec 017).\n\nThis module implements the PositionRecoveryProvider for loading positions\nfrom cache and reconciling them with exchange state.\n\nKey Responsibilities:\n- Load cached positions from NautilusTrader cache\n- Query current exchange positions\n- Reconcile discrepancies (exchange is source of truth)\n- Generate discrepancy messages for logging\n\nImplementation Note:\n    Selected via Alpha-Evolve process from 3 approaches:\n    - Approach A: Simple Iterative (O(n*m)) - rejected for performance\n    - Approach B: Dictionary-Based (O(n+m)) - SELECTED (winner)\n    - Approach C: Dataclass-Based - rejected for over-engineering\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom typing import TYPE_CHECKING, Any\n\nif TYPE_CHECKING:\n    from nautilus_trader.model.identifiers import TraderId\n    from nautilus_trader.model.position import Position\n\n\n# Module logger\n_log = logging.getLogger(__name__)\n\n\nclass PositionRecoveryProvider:\n    \"\"\"Provider for position recovery and reconciliation.\n\n    Implements the PositionRecoveryProvider interface from Spec 017.\n    Uses dictionary-based lookups for O(n+m) reconciliation complexity.\n\n    Attributes:\n        cache: NautilusTrader cache instance for position access.\n        logger: Optional custom logger instance.\n\n    Example:\n        >>> provider = PositionRecoveryProvider(cache=node.cache)\n        >>> cached = provider.get_cached_positions(trader_id=\"TRADER-001\")\n        >>> exchange = provider.get_exchange_positions(trader_id=\"TRADER-001\")\n        >>> reconciled, discrepancies = provider.reconcile_positions(cached, exchange)\n    \"\"\"\n\n    def __init__(\n        self,\n        cache: Any,\n        logger: logging.Logger | None = None,\n    ) -> None:\n        \"\"\"Initialize the PositionRecoveryProvider.\n\n        Args:\n            cache: NautilusTrader cache instance.\n            logger: Optional custom logger. If None, uses module logger.\n        \"\"\"\n        self._cache = cache\n        self._log = logger or _log\n\n    def get_cached_positions(self, trader_id: str | TraderId) -> list[Position]:\n        \"\"\"Load positions from cache.\n\n        Retrieves all positions from the NautilusTrader cache.\n        Both open and closed positions are returned; filtering is\n        the caller's responsibility.\n\n        Args:\n            trader_id: The trader identifier (used for logging context).\n\n        Returns:\n            List of cached positions.\n        \"\"\"\n        self._log.info(\"Loading cached positions for trader_id=%s\", trader_id)\n        \n        positions = list(self._cache.positions())\n        \n        self._log.info(\n            \"Loaded %d positions from cache for trader_id=%s\",\n            len(positions),\n            trader_id,\n        )\n        \n        # Log individual positions at DEBUG level\n        for pos in positions:\n            self._log.debug(\n                \"Cached position: instrument=%s side=%s qty=%s\",\n                pos.instrument_id.value,\n                pos.side.value,\n                pos.quantity.as_decimal(),\n            )\n        \n        return positions\n\n    def get_exchange_positions(self, trader_id: str | TraderId) -> list[Position]:\n        \"\"\"Query current positions from exchange.\n\n        In live trading, this would query the exchange directly.\n        For testing/simulation, returns positions from cache.\n\n        Note:\n            In production, this method should be overridden to query\n            the actual exchange via the execution client.\n\n        Args:\n            trader_id: The trader identifier.\n\n        Returns:\n            List of positions reported by exchange.\n        \"\"\"\n        self._log.info(\"Querying exchange positions for trader_id=%s\", trader_id)\n        \n        # Default implementation returns cache positions\n        # In production, override to query exchange directly\n        positions = list(self._cache.positions())\n        \n        self._log.info(\n            \"Retrieved %d positions from exchange for trader_id=%s\",\n            len(positions),\n            trader_id,\n        )\n        \n        # Log individual positions at DEBUG level\n        for pos in positions:\n            self._log.debug(\n                \"Exchange position: instrument=%s side=%s qty=%s\",\n                pos.instrument_id.value,\n                pos.side.value,\n                pos.quantity.as_decimal(),\n            )\n        \n        return positions\n\n    def reconcile_positions(\n        self,\n        cached: list[Position],\n        exchange: list[Position],\n    ) -> tuple[list[Position], list[str]]:\n        \"\"\"Reconcile cached positions with exchange positions.\n\n        Compares positions by instrument_id and detects discrepancies:\n        - Quantity mismatches (cache vs exchange quantity differs)\n        - Side mismatches (cache LONG but exchange SHORT, or vice versa)\n        - External positions (on exchange but not in cache)\n        - Closed positions (in cache but not on exchange)\n\n        The exchange is always the SOURCE OF TRUTH. Reconciled positions\n        are the exchange positions, not the cached ones.\n\n        Args:\n            cached: Positions loaded from cache.\n            exchange: Positions from exchange query.\n\n        Returns:\n            Tuple of (reconciled_positions, discrepancy_messages).\n            - reconciled_positions: List of exchange positions (source of truth)\n            - discrepancy_messages: List of human-readable discrepancy strings\n\n        Example:\n            >>> reconciled, discrepancies = provider.reconcile_positions(\n            ...     cached=[cached_btc],\n            ...     exchange=[exchange_btc, exchange_eth],\n            ... )\n            >>> for msg in discrepancies:\n            ...     logger.warning(msg)\n        \"\"\"\n        self._log.info(\n            \"Reconciling positions: cached=%d exchange=%d\",\n            len(cached),\n            len(exchange),\n        )\n        \n        reconciled: list[Position] = []\n        discrepancies: list[str] = []\n\n        # Build lookup maps for O(1) access - O(n) + O(m)\n        cached_map: dict[str, Position] = {\n            pos.instrument_id.value: pos for pos in cached\n        }\n        exchange_map: dict[str, Position] = {\n            pos.instrument_id.value: pos for pos in exchange\n        }\n\n        # Process exchange positions (source of truth) - O(m)\n        for instrument_id, ex_pos in exchange_map.items():\n            ex_qty = ex_pos.quantity.as_decimal()\n            ex_side = ex_pos.side.value\n\n            if instrument_id in cached_map:\n                # Position exists in both cache and exchange\n                cached_pos = cached_map[instrument_id]\n                cached_qty = cached_pos.quantity.as_decimal()\n                cached_side = cached_pos.side.value\n\n                # Check for quantity mismatch\n                if cached_qty != ex_qty:\n                    msg = (\n                        f\"Quantity mismatch for {instrument_id}: \"\n                        f\"cached={cached_qty}, exchange={ex_qty}\"\n                    )\n                    discrepancies.append(msg)\n                    self._log.warning(msg)\n\n                # Check for side mismatch\n                if cached_side != ex_side:\n                    msg = (\n                        f\"Side mismatch for {instrument_id}: \"\n                        f\"cached={cached_side}, exchange={ex_side}\"\n                    )\n                    discrepancies.append(msg)\n                    self._log.warning(msg)\n                \n                if cached_qty == ex_qty and cached_side == ex_side:\n                    self._log.debug(\n                        \"Position matches: %s %s %s\",\n                        instrument_id,\n                        ex_side,\n                        ex_qty,\n                    )\n            else:\n                # External position (on exchange but not in cache)\n                msg = f\"External position detected: {instrument_id} {ex_side} {ex_qty}\"\n                discrepancies.append(msg)\n                self._log.warning(msg)\n\n            # Exchange is source of truth - add to reconciled\n            reconciled.append(ex_pos)\n\n        # Find positions closed on exchange (in cache but not on exchange) - O(n)\n        for instrument_id in cached_map:\n            if instrument_id not in exchange_map:\n                msg = (\n                    f\"Position closed on exchange: {instrument_id} \"\n                    f\"(missing from exchange)\"\n                )\n                discrepancies.append(msg)\n                self._log.warning(msg)\n\n        self._log.info(\n            \"Reconciliation complete: reconciled=%d discrepancies=%d\",\n            len(reconciled),\n            len(discrepancies),\n        )\n\n        return reconciled, discrepancies\nEOF",
      "description": "Write updated provider.py with logging"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:35:37.897437",
      "todo_count": 4
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:35:48.247343",
      "command": "cat > /media/sam/1TB/nautilus_dev/strategies/common/recovery/__init__.py << 'EOF'\n\"\"\"Position Recovery Module (Spec 017).\n\nThis module provides position recovery capabilities for NautilusTrader\nstrategies, enabling seamless state restoration after TradingNode restarts.\n\nKey Components:\n- RecoveryConfig: Configuration for recovery behavior\n- RecoverableStrategy: Base class with recovery support\n- PositionRecoveryProvider: Position loading and reconciliation\n- RecoveryEventEmitter: Event emission for monitoring\n\"\"\"\n\nfrom strategies.common.recovery.config import RecoveryConfig\nfrom strategies.common.recovery.models import (\n    IndicatorState,\n    PositionSnapshot,\n    RecoveryState,\n    RecoveryStatus,\n    StrategySnapshot,\n)\nfrom strategies.common.recovery.provider import PositionRecoveryProvider\n\n__all__ = [\n    # Config\n    \"RecoveryConfig\",\n    # Models\n    \"RecoveryStatus\",\n    \"RecoveryState\",\n    \"PositionSnapshot\",\n    \"IndicatorState\",\n    \"StrategySnapshot\",\n    # Provider\n    \"PositionRecoveryProvider\",\n]\nEOF",
      "description": "Update __init__.py with PositionRecoveryProvider export"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:35:54.067583",
      "command": "cat > /media/sam/1TB/nautilus_dev/strategies/common/recovery/recoverable_strategy.py << 'EOF'\n\"\"\"Recoverable Strategy Base Class (Spec 017 - FR-002).\n\nThis module provides a Strategy base class with position recovery support.\nImplements FR-002 (Strategy State Restoration) from Spec 017.\n\nKey Features:\n- Automatic position detection on startup\n- Historical data warmup for indicators\n- Exit order recreation for recovered positions\n- Trading blocked until warmup completes\n\nUsage:\n    class MyStrategy(RecoverableStrategy):\n        def __init__(self, config: MyConfig) -> None:\n            super().__init__(config, recovery_config)\n            self.ema = ExponentialMovingAverage(period=20)\n\n        def on_position_recovered(self, position: Position) -> None:\n            self.log.info(f\"Recovered position: {position.instrument_id}\")\n\n        def on_warmup_complete(self) -> None:\n            self.log.info(\"Warmup complete, ready to trade\")\n\n        def on_bar(self, bar: Bar) -> None:\n            if not self._warmup_complete:\n                return  # Skip until warmup completes\n            # Trading logic here\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom datetime import timedelta\nfrom typing import TYPE_CHECKING, Any\n\nfrom nautilus_trader.config import StrategyConfig\nfrom nautilus_trader.model.data import Bar, BarType\nfrom nautilus_trader.model.enums import OrderSide, OrderType, TimeInForce\nfrom nautilus_trader.model.identifiers import InstrumentId\nfrom nautilus_trader.model.position import Position\nfrom nautilus_trader.trading.strategy import Strategy\n\nfrom strategies.common.recovery.config import RecoveryConfig\nfrom strategies.common.recovery.models import RecoveryState, RecoveryStatus\n\nif TYPE_CHECKING:\n    from nautilus_trader.model.instruments import Instrument\n    from nautilus_trader.model.orders import Order\n\n\nclass RecoverableStrategyConfig(StrategyConfig, frozen=True):\n    \"\"\"Configuration for RecoverableStrategy.\n\n    Attributes:\n        instrument_id: The instrument to trade.\n        bar_type: The bar type for data subscription and warmup.\n        recovery: Recovery configuration settings.\n    \"\"\"\n\n    instrument_id: str\n    bar_type: str\n    recovery: RecoveryConfig | None = None\n\n\nclass RecoverableStrategy(Strategy):\n    \"\"\"Strategy base class with position recovery support.\n\n    Implements FR-002 (Strategy State Restoration) from Spec 017:\n    - Detects recovered positions from cache on startup\n    - Requests historical data for indicator warmup\n    - Recreates exit orders (stop-loss) for recovered positions\n    - Blocks trading until warmup completes\n\n    Attributes:\n        instrument_id: The instrument being traded.\n        bar_type: The bar type for data and warmup.\n        recovery_config: Recovery configuration.\n        recovery_state: Current recovery state.\n\n    Example:\n        >>> class MyStrategy(RecoverableStrategy):\n        ...     def on_bar(self, bar: Bar) -> None:\n        ...         if not self._warmup_complete:\n        ...             return  # Skip until ready\n        ...         # Trading logic\n    \"\"\"\n\n    def __init__(\n        self,\n        config: RecoverableStrategyConfig,\n    ) -> None:\n        \"\"\"Initialize RecoverableStrategy.\n\n        Args:\n            config: Strategy configuration with recovery settings.\n        \"\"\"\n        super().__init__(config)\n\n        self.instrument_id = InstrumentId.from_str(config.instrument_id)\n        self.bar_type = BarType.from_str(config.bar_type)\n\n        # Recovery configuration (use defaults if not provided)\n        self.recovery_config = config.recovery or RecoveryConfig(\n            trader_id=str(self.trader_id) if hasattr(self, \"trader_id\") else \"TRADER-001\"\n        )\n\n        # Recovery state tracking\n        self.recovery_state = RecoveryState()\n        self._warmup_complete: bool = False\n        self._warmup_bars_processed: int = 0\n        self._warmup_start_ns: int | None = None\n        self._recovered_positions: list[Position] = []\n\n        # Instrument reference (set in on_start)\n        self.instrument: Instrument | None = None\n\n    # ─────────────────────────────────────────────────────────────────\n    # Lifecycle Hooks\n    # ─────────────────────────────────────────────────────────────────\n\n    def on_start(self) -> None:\n        \"\"\"Initialize strategy and detect recovered positions.\n\n        Called when the strategy starts. Performs:\n        1. Load instrument from cache\n        2. Detect recovered positions\n        3. Handle each recovered position (log + call hook)\n        4. Request historical data for indicator warmup\n        \"\"\"\n        # Load instrument\n        self.instrument = self.cache.instrument(self.instrument_id)\n        if self.instrument is None:\n            self.log.error(f\"Instrument {self.instrument_id} not found in cache\")\n            self.stop()\n            return\n\n        # Start recovery tracking\n        self.recovery_state = RecoveryState(\n            status=RecoveryStatus.IN_PROGRESS,\n            ts_started=self.clock.timestamp_ns(),\n        )\n        self._warmup_start_ns = self.clock.timestamp_ns()\n\n        # Check for recovered positions from cache\n        if self.recovery_config.recovery_enabled:\n            self._detect_recovered_positions()\n\n        # Request historical data for indicator warmup\n        self._request_warmup_data()\n\n        # Subscribe to bars for live trading\n        self.subscribe_bars(self.bar_type)\n\n        self.log.info(\n            f\"RecoverableStrategy started: \"\n            f\"instrument={self.instrument_id}, \"\n            f\"recovery_enabled={self.recovery_config.recovery_enabled}, \"\n            f\"warmup_days={self.recovery_config.warmup_lookback_days}\"\n        )\n\n    def on_stop(self) -> None:\n        \"\"\"Clean up on strategy stop.\"\"\"\n        self.log.info(\n            f\"RecoverableStrategy stopped: \"\n            f\"positions_recovered={self.recovery_state.positions_recovered}, \"\n            f\"warmup_complete={self._warmup_complete}\"\n        )\n\n    # ─────────────────────────────────────────────────────────────────\n    # Position Recovery (FR-002)\n    # ─────────────────────────────────────────────────────────────────\n\n    def _detect_recovered_positions(self) -> None:\n        \"\"\"Detect and process positions from cache.\n\n        Iterates over cached positions for this instrument and\n        handles each open position as recovered.\n        \"\"\"\n        positions = self.cache.positions(instrument_id=self.instrument_id)\n\n        for position in positions:\n            if position.is_open:\n                self._handle_recovered_position(position)\n\n        self.log.info(\n            f\"Position detection complete: \"\n            f\"found {len(self._recovered_positions)} open positions\"\n        )\n\n    def _handle_recovered_position(self, position: Position) -> None:\n        \"\"\"Internal handler for a recovered position.\n\n        Logs the recovery, updates state, sets up exit orders,\n        and calls the subclass hook.\n\n        Args:\n            position: The recovered position.\n        \"\"\"\n        self._recovered_positions.append(position)\n        self.recovery_state = RecoveryState(\n            status=self.recovery_state.status,\n            positions_recovered=self.recovery_state.positions_recovered + 1,\n            indicators_warmed=self.recovery_state.indicators_warmed,\n            orders_reconciled=self.recovery_state.orders_reconciled,\n            ts_started=self.recovery_state.ts_started,\n            ts_completed=self.recovery_state.ts_completed,\n        )\n\n        # Log recovery details\n        self.log.info(\n            f\"Recovered position: \"\n            f\"instrument={position.instrument_id}, \"\n            f\"side={position.side.value}, \"\n            f\"quantity={position.quantity}, \"\n            f\"avg_price={position.avg_px_open}\"\n        )\n\n        # Setup exit orders if needed\n        self._setup_exit_orders(position)\n\n        # Call subclass hook\n        self.on_position_recovered(position)\n\n    def on_position_recovered(self, position: Position) -> None:\n        \"\"\"Hook for subclasses to handle recovered positions.\n\n        Override this method to implement custom recovery logic,\n        such as restoring strategy-specific state or adjusting\n        risk parameters.\n\n        Args:\n            position: The recovered position.\n\n        Example:\n            >>> def on_position_recovered(self, position: Position) -> None:\n            ...     self._position_size = position.quantity\n            ...     self._entry_price = position.avg_px_open\n        \"\"\"\n        pass  # Override in subclass\n\n    def _setup_exit_orders(self, position: Position) -> None:\n        \"\"\"Setup exit orders (stop-loss) for a recovered position.\n\n        Checks if a stop-loss order already exists for the position.\n        If not, this method can be overridden to create one.\n\n        Note:\n            This base implementation only checks for existing orders.\n            Subclasses should override to implement actual stop-loss\n            creation logic based on their risk parameters.\n\n        Args:\n            position: The recovered position needing exit orders.\n        \"\"\"\n        # Check if stop-loss already exists\n        open_orders = self.cache.orders_open(instrument_id=position.instrument_id)\n        has_stop = any(\n            self._is_stop_order(order) for order in open_orders\n        )\n\n        if has_stop:\n            self.log.info(\n                f\"Stop-loss already exists for {position.instrument_id}\"\n            )\n        else:\n            self.log.warning(\n                f\"No stop-loss found for recovered position: \"\n                f\"{position.instrument_id}. Override _setup_exit_orders() \"\n                f\"to create one.\"\n            )\n\n    def _is_stop_order(self, order: Order) -> bool:\n        \"\"\"Check if an order is a stop-type order.\n\n        Args:\n            order: The order to check.\n\n        Returns:\n            True if order is STOP_MARKET or STOP_LIMIT.\n        \"\"\"\n        return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n    # ─────────────────────────────────────────────────────────────────\n    # Historical Data Warmup (FR-002)\n    # ─────────────────────────────────────────────────────────────────\n\n    def _request_warmup_data(self) -> None:\n        \"\"\"Request historical bars for indicator warmup.\n\n        Requests bars from (now - warmup_lookback_days) to now.\n        Results are delivered to on_historical_data().\n        \"\"\"\n        lookback_days = self.recovery_config.warmup_lookback_days\n        start_time = self.clock.utc_now() - timedelta(days=lookback_days)\n\n        self.log.info(\n            f\"Requesting warmup data: \"\n            f\"bar_type={self.bar_type}, \"\n            f\"start={start_time}, \"\n            f\"lookback_days={lookback_days}\"\n        )\n\n        # Request historical bars with callback\n        self.request_bars(\n            bar_type=self.bar_type,\n            start=start_time,\n            callback=self._on_warmup_data_received,\n        )\n\n    def _on_warmup_data_received(self, bars: list[Bar]) -> None:\n        \"\"\"Callback when historical warmup data is received.\n\n        Processes bars for indicator warmup and marks warmup complete.\n\n        Args:\n            bars: List of historical bars for warmup.\n        \"\"\"\n        if not bars:\n            self.log.warning(\"No warmup bars received\")\n            self._complete_warmup()\n            return\n\n        self.log.info(f\"Received {len(bars)} warmup bars\")\n\n        # Sort bars by timestamp (oldest first) for correct indicator warmup\n        sorted_bars = sorted(bars, key=lambda b: b.ts_event)\n\n        # Process each bar for indicator warmup\n        for bar in sorted_bars:\n            self.on_historical_data(bar)\n            self._warmup_bars_processed += 1\n\n        # Mark warmup complete\n        self._complete_warmup()\n\n    def on_historical_data(self, bar: Bar) -> None:\n        \"\"\"Process a historical bar for indicator warmup.\n\n        Override this method to feed bars to your indicators.\n\n        Args:\n            bar: A historical bar for warmup.\n\n        Example:\n            >>> def on_historical_data(self, bar: Bar) -> None:\n            ...     self.ema.handle_bar(bar)\n            ...     self.rsi.handle_bar(bar)\n        \"\"\"\n        pass  # Override in subclass to warm up indicators\n\n    def _complete_warmup(self) -> None:\n        \"\"\"Complete the warmup phase and enable trading.\n\n        Updates recovery state, calculates warmup duration,\n        and calls the on_warmup_complete() hook.\n        \"\"\"\n        self._warmup_complete = True\n\n        # Calculate warmup duration\n        warmup_duration_ns = 0\n        if self._warmup_start_ns is not None:\n            warmup_duration_ns = self.clock.timestamp_ns() - self._warmup_start_ns\n        warmup_duration_ms = warmup_duration_ns / 1_000_000\n\n        # Update recovery state\n        self.recovery_state = RecoveryState(\n            status=RecoveryStatus.COMPLETED,\n            positions_recovered=self.recovery_state.positions_recovered,\n            indicators_warmed=True,\n            orders_reconciled=True,\n            ts_started=self.recovery_state.ts_started,\n            ts_completed=self.clock.timestamp_ns(),\n        )\n\n        self.log.info(\n            f\"Warmup complete: \"\n            f\"bars_processed={self._warmup_bars_processed}, \"\n            f\"duration_ms={warmup_duration_ms:.1f}\"\n        )\n\n        # Call subclass hook\n        self.on_warmup_complete()\n\n    def on_warmup_complete(self) -> None:\n        \"\"\"Hook called when warmup phase completes.\n\n        Override this method to perform post-warmup initialization,\n        such as subscribing to additional data feeds or enabling\n        trading signals.\n\n        Example:\n            >>> def on_warmup_complete(self) -> None:\n            ...     self.log.info(\"Strategy ready to trade\")\n            ...     self._can_trade = True\n        \"\"\"\n        pass  # Override in subclass\n\n    # ─────────────────────────────────────────────────────────────────\n    # Helper Properties\n    # ─────────────────────────────────────────────────────────────────\n\n    @property\n    def is_warming_up(self) -> bool:\n        \"\"\"Check if strategy is still in warmup phase.\n\n        Returns:\n            True if warmup is not yet complete.\n        \"\"\"\n        return not self._warmup_complete\n\n    @property\n    def is_ready(self) -> bool:\n        \"\"\"Check if strategy is ready to trade.\n\n        Returns:\n            True if warmup is complete and recovery succeeded.\n        \"\"\"\n        return (\n            self._warmup_complete\n            and self.recovery_state.status == RecoveryStatus.COMPLETED\n        )\n\n    @property\n    def recovered_positions_count(self) -> int:\n        \"\"\"Get the number of recovered positions.\n\n        Returns:\n            Number of positions recovered during startup.\n        \"\"\"\n        return len(self._recovered_positions)\nEOF\necho \"Created: /media/sam/1TB/nautilus_dev/strategies/common/recovery/recoverable_strategy.py\"",
      "description": "Create RecoverableStrategy class"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:35:54.430090",
      "todo_count": 4
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:36:03.567323",
      "todo_count": 10
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:36:09.628151",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/__init__.py"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:36:17.751720",
      "command": "cat > /media/sam/1TB/nautilus_dev/strategies/common/recovery/__init__.py << 'EOF'\n\"\"\"Position Recovery Module (Spec 017).\n\nThis module provides position recovery capabilities for NautilusTrader\nstrategies, enabling seamless state restoration after TradingNode restarts.\n\nKey Components:\n- RecoveryConfig: Configuration for recovery behavior\n- RecoverableStrategy: Base class with recovery support\n- PositionRecoveryProvider: Position loading and reconciliation\n- RecoveryEventEmitter: Event emission for monitoring\n\"\"\"\n\nfrom strategies.common.recovery.config import RecoveryConfig\nfrom strategies.common.recovery.models import (\n    IndicatorState,\n    PositionSnapshot,\n    RecoveryState,\n    RecoveryStatus,\n    StrategySnapshot,\n)\nfrom strategies.common.recovery.provider import PositionRecoveryProvider\nfrom strategies.common.recovery.recoverable_strategy import (\n    RecoverableStrategy,\n    RecoverableStrategyConfig,\n)\n\n__all__ = [\n    # Config\n    \"RecoveryConfig\",\n    # Models\n    \"RecoveryStatus\",\n    \"RecoveryState\",\n    \"PositionSnapshot\",\n    \"IndicatorState\",\n    \"StrategySnapshot\",\n    # Provider\n    \"PositionRecoveryProvider\",\n    # Strategy\n    \"RecoverableStrategy\",\n    \"RecoverableStrategyConfig\",\n]\nEOF\necho \"Updated: /media/sam/1TB/nautilus_dev/strategies/common/recovery/__init__.py\"",
      "description": "Update __init__.py exports"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:36:22.667056",
      "command": "cat > /media/sam/1TB/nautilus_dev/tests/unit/recovery/conftest.py << 'EOF'\n\"\"\"Unit test fixtures for recovery module (Spec 017).\n\nThese fixtures provide mocks for unit testing position recovery\nwithout requiring NautilusTrader adapter dependencies.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom datetime import datetime, timezone\nfrom decimal import Decimal\nfrom unittest.mock import MagicMock\n\nimport pytest\n\n\n@pytest.fixture\ndef mock_cache():\n    \"\"\"Create a mock NautilusTrader cache for testing.\n    \n    Returns a MagicMock with common cache methods stubbed:\n    - positions(): Returns empty list by default\n    - positions_open(): Returns empty list by default\n    - orders_open(): Returns empty list by default\n    - account(): Returns None by default\n    \"\"\"\n    cache = MagicMock()\n    cache.positions.return_value = []\n    cache.positions_open.return_value = []\n    cache.orders_open.return_value = []\n    cache.account.return_value = None\n    return cache\n\n\n@pytest.fixture\ndef mock_clock():\n    \"\"\"Create a mock clock for testing.\n    \n    Returns a MagicMock with:\n    - timestamp_ns(): Returns fixed nanosecond timestamp\n    - utc_now(): Returns fixed datetime (2024-01-02 00:00:00 UTC)\n    \"\"\"\n    clock = MagicMock()\n    clock.timestamp_ns.return_value = 1704153600000000000\n    clock.utc_now.return_value = datetime(2024, 1, 2, 0, 0, 0, tzinfo=timezone.utc)\n    return clock\n\n\n@pytest.fixture\ndef mock_logger():\n    \"\"\"Create a mock logger for testing log output.\n    \n    Returns a MagicMock with standard logging methods stubbed.\n    \"\"\"\n    logger = MagicMock()\n    logger.debug = MagicMock()\n    logger.info = MagicMock()\n    logger.warning = MagicMock()\n    logger.error = MagicMock()\n    return logger\n\n\n@pytest.fixture\ndef recovery_config():\n    \"\"\"Create a default RecoveryConfig for testing.\"\"\"\n    from strategies.common.recovery.config import RecoveryConfig\n\n    return RecoveryConfig(\n        trader_id=\"TESTER-001\",\n        recovery_enabled=True,\n        warmup_lookback_days=2,\n        startup_delay_secs=10.0,\n        max_recovery_time_secs=30.0,\n        claim_external_positions=True,\n    )\n\n\n@pytest.fixture\ndef position_snapshot():\n    \"\"\"Create a sample PositionSnapshot for testing.\"\"\"\n    from strategies.common.recovery.models import PositionSnapshot\n\n    return PositionSnapshot(\n        instrument_id=\"BTCUSDT-PERP.BINANCE\",\n        side=\"LONG\",\n        quantity=Decimal(\"1.5\"),\n        avg_entry_price=Decimal(\"42000.00\"),\n        unrealized_pnl=Decimal(\"500.00\"),\n        realized_pnl=Decimal(\"0.00\"),\n        ts_opened=1704067200000000000,\n        ts_last_updated=1704153600000000000,\n    )\n\n\n@pytest.fixture\ndef recovery_state_pending():\n    \"\"\"Create a pending RecoveryState for testing.\"\"\"\n    from strategies.common.recovery.models import RecoveryState, RecoveryStatus\n\n    return RecoveryState(\n        status=RecoveryStatus.PENDING,\n        positions_recovered=0,\n        indicators_warmed=False,\n        orders_reconciled=False,\n    )\n\n\n@pytest.fixture\ndef recovery_state_complete():\n    \"\"\"Create a completed RecoveryState for testing.\"\"\"\n    from strategies.common.recovery.models import RecoveryState, RecoveryStatus\n\n    return RecoveryState(\n        status=RecoveryStatus.COMPLETED,\n        positions_recovered=2,\n        indicators_warmed=True,\n        orders_reconciled=True,\n        ts_started=1704067200000000000,\n        ts_completed=1704067205000000000,\n    )\n\n\ndef create_mock_position(\n    instrument_id: str,\n    side: str = \"LONG\",\n    quantity: Decimal = Decimal(\"1.0\"),\n    avg_px_open: Decimal = Decimal(\"1000.00\"),\n    is_open: bool = True,\n) -> MagicMock:\n    \"\"\"Factory function to create mock positions.\n    \n    Args:\n        instrument_id: Full instrument ID (e.g., BTCUSDT-PERP.BINANCE)\n        side: Position side (LONG or SHORT)\n        quantity: Position quantity\n        avg_px_open: Average entry price\n        is_open: Whether position is currently open\n        \n    Returns:\n        MagicMock configured as a Position object\n    \"\"\"\n    pos = MagicMock()\n    pos.instrument_id = MagicMock()\n    pos.instrument_id.value = instrument_id\n    pos.side = MagicMock()\n    pos.side.value = side\n    pos.quantity = MagicMock()\n    pos.quantity.as_decimal.return_value = quantity\n    pos.avg_px_open = MagicMock()\n    pos.avg_px_open.as_decimal.return_value = avg_px_open\n    pos.is_open = is_open\n    return pos\n\n\n@pytest.fixture\ndef mock_btc_position():\n    \"\"\"Create a mock BTC position.\"\"\"\n    return create_mock_position(\n        instrument_id=\"BTCUSDT-PERP.BINANCE\",\n        side=\"LONG\",\n        quantity=Decimal(\"1.5\"),\n        avg_px_open=Decimal(\"42000.00\"),\n    )\n\n\n@pytest.fixture\ndef mock_eth_position():\n    \"\"\"Create a mock ETH position.\"\"\"\n    return create_mock_position(\n        instrument_id=\"ETHUSDT-PERP.BINANCE\",\n        side=\"SHORT\",\n        quantity=Decimal(\"10.0\"),\n        avg_px_open=Decimal(\"2200.00\"),\n    )\nEOF",
      "description": "Create unit test conftest with fixtures"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:36:26.417895",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff check strategies/common/recovery/recoverable_strategy.py --fix 2>&1",
      "description": "Run ruff check on recoverable_strategy.py"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:36:29.724892",
      "todo_count": 4
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:36:33.768407",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff format /media/sam/1TB/nautilus_dev/strategies/common/recovery/recoverable_strategy.py 2>&1",
      "description": "Run ruff format on recoverable_strategy.py"
    },
    {
      "operation": "taskoutput",
      "timestamp": "2025-12-30T19:36:36.207950",
      "task_id": "aa47bef",
      "block": false,
      "timeout": 30000
    },
    {
      "operation": "taskoutput",
      "timestamp": "2025-12-30T19:36:36.214350",
      "task_id": "a016601",
      "block": false,
      "timeout": 30000
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:36:37.138272",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && python -m pytest tests/unit/recovery/ -v --tb=short 2>&1 | head -100",
      "description": "Run unit recovery tests"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:36:41.299263",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff check strategies/common/recovery/ --fix && ruff format strategies/common/recovery/ 2>&1",
      "description": "Run ruff on entire recovery module"
    },
    {
      "operation": "taskoutput",
      "timestamp": "2025-12-30T19:36:43.945396",
      "task_id": "aa47bef",
      "block": true,
      "timeout": 120000
    },
    {
      "operation": "taskoutput",
      "timestamp": "2025-12-30T19:36:43.953705",
      "task_id": "a016601",
      "block": true,
      "timeout": 120000
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:36:48.018084",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && python -m pytest tests/integration/recovery/ -v --tb=short 2>&1 | head -100",
      "description": "Run integration recovery tests"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:36:53.173675",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && python -c \"\nfrom strategies.common.recovery import (\n    RecoveryConfig,\n    RecoveryStatus,\n    RecoveryState,\n    PositionSnapshot,\n    IndicatorState,\n    StrategySnapshot,\n    PositionRecoveryProvider,\n    RecoverableStrategy,\n    RecoverableStrategyConfig,\n)\nprint('All imports successful!')\nprint(f'RecoverableStrategy: {RecoverableStrategy}')\nprint(f'RecoverableStrategyConfig: {RecoverableStrategyConfig}')\n\" 2>&1",
      "description": "Verify imports work"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:36:54.575997",
      "file_path": "/media/sam/1TB/nautilus_dev/tests/integration/recovery/test_cold_start.py"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:37:02.716059",
      "todo_count": 10
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:37:09.613153",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/recoverable_strategy.py"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:37:39.163599",
      "command": "cat > /media/sam/1TB/nautilus_dev/strategies/common/recovery/provider.py << 'EOF'\n\"\"\"Position Recovery Provider (Spec 017).\n\nThis module implements the PositionRecoveryProvider for loading positions\nfrom cache and reconciling them with exchange state.\n\nKey Responsibilities:\n- Load cached positions from NautilusTrader cache\n- Query current exchange positions\n- Reconcile discrepancies (exchange is source of truth)\n- Generate discrepancy messages for logging\n\nImplementation Note:\n    Selected via Alpha-Evolve process from 3 approaches:\n    - Approach A: Simple Iterative (O(n*m)) - rejected for performance\n    - Approach B: Dictionary-Based (O(n+m)) - SELECTED (winner)\n    - Approach C: Dataclass-Based - rejected for over-engineering\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom typing import TYPE_CHECKING, Any\n\nif TYPE_CHECKING:\n    from nautilus_trader.model.identifiers import TraderId\n    from nautilus_trader.model.position import Position\n\n\n# Module logger\n_log = logging.getLogger(__name__)\n\n\nclass PositionRecoveryProvider:\n    \"\"\"Provider for position recovery and reconciliation.\n\n    Implements the PositionRecoveryProvider interface from Spec 017.\n    Uses dictionary-based lookups for O(n+m) reconciliation complexity.\n\n    Attributes:\n        cache: NautilusTrader cache instance for position access.\n        logger: Optional custom logger instance.\n        discrepancy_count: Number of discrepancies found in last reconciliation.\n\n    Example:\n        >>> provider = PositionRecoveryProvider(cache=node.cache)\n        >>> cached = provider.get_cached_positions(trader_id=\"TRADER-001\")\n        >>> exchange = provider.get_exchange_positions(trader_id=\"TRADER-001\")\n        >>> reconciled, discrepancies = provider.reconcile_positions(cached, exchange)\n    \"\"\"\n\n    def __init__(\n        self,\n        cache: Any,\n        logger: logging.Logger | None = None,\n    ) -> None:\n        \"\"\"Initialize the PositionRecoveryProvider.\n\n        Args:\n            cache: NautilusTrader cache instance.\n            logger: Optional custom logger. If None, uses module logger.\n        \"\"\"\n        self._cache = cache\n        self._log = logger or _log\n        self._discrepancy_count: int = 0\n\n    @property\n    def discrepancy_count(self) -> int:\n        \"\"\"Number of discrepancies found in the last reconciliation.\n        \n        Returns:\n            Count of discrepancies from the most recent reconcile_positions() call.\n        \"\"\"\n        return self._discrepancy_count\n\n    def get_cached_positions(self, trader_id: str | TraderId) -> list[Position]:\n        \"\"\"Load positions from cache.\n\n        Retrieves all positions from the NautilusTrader cache.\n        Both open and closed positions are returned; filtering is\n        the caller's responsibility.\n\n        Args:\n            trader_id: The trader identifier (used for logging context).\n\n        Returns:\n            List of cached positions.\n        \"\"\"\n        self._log.info(\"Loading cached positions for trader_id=%s\", trader_id)\n        \n        positions = list(self._cache.positions())\n        \n        self._log.info(\n            \"Loaded %d positions from cache for trader_id=%s\",\n            len(positions),\n            trader_id,\n        )\n        \n        # Log individual positions at DEBUG level\n        for pos in positions:\n            self._log.debug(\n                \"Cached position: instrument=%s side=%s qty=%s\",\n                pos.instrument_id.value,\n                pos.side.value,\n                pos.quantity.as_decimal(),\n            )\n        \n        return positions\n\n    def get_exchange_positions(self, trader_id: str | TraderId) -> list[Position]:\n        \"\"\"Query current positions from exchange.\n\n        In live trading, this would query the exchange directly.\n        For testing/simulation, returns positions from cache.\n\n        Note:\n            In production, this method should be overridden to query\n            the actual exchange via the execution client.\n\n        Args:\n            trader_id: The trader identifier.\n\n        Returns:\n            List of positions reported by exchange.\n        \"\"\"\n        self._log.info(\"Querying exchange positions for trader_id=%s\", trader_id)\n        \n        # Default implementation returns cache positions\n        # In production, override to query exchange directly\n        positions = list(self._cache.positions())\n        \n        self._log.info(\n            \"Retrieved %d positions from exchange for trader_id=%s\",\n            len(positions),\n            trader_id,\n        )\n        \n        # Log individual positions at DEBUG level\n        for pos in positions:\n            self._log.debug(\n                \"Exchange position: instrument=%s side=%s qty=%s\",\n                pos.instrument_id.value,\n                pos.side.value,\n                pos.quantity.as_decimal(),\n            )\n        \n        return positions\n\n    def reconcile_positions(\n        self,\n        cached: list[Position],\n        exchange: list[Position],\n    ) -> tuple[list[Position], list[str]]:\n        \"\"\"Reconcile cached positions with exchange positions.\n\n        Compares positions by instrument_id and detects discrepancies:\n        - Quantity mismatches (cache vs exchange quantity differs)\n        - Side mismatches (cache LONG but exchange SHORT, or vice versa)\n        - External positions (on exchange but not in cache)\n        - Closed positions (in cache but not on exchange)\n\n        The exchange is always the SOURCE OF TRUTH. Reconciled positions\n        are the exchange positions, not the cached ones.\n\n        Args:\n            cached: Positions loaded from cache.\n            exchange: Positions from exchange query.\n\n        Returns:\n            Tuple of (reconciled_positions, discrepancy_messages).\n            - reconciled_positions: List of exchange positions (source of truth)\n            - discrepancy_messages: List of human-readable discrepancy strings\n\n        Example:\n            >>> reconciled, discrepancies = provider.reconcile_positions(\n            ...     cached=[cached_btc],\n            ...     exchange=[exchange_btc, exchange_eth],\n            ... )\n            >>> for msg in discrepancies:\n            ...     logger.warning(msg)\n        \"\"\"\n        self._log.info(\n            \"Reconciling positions: cached=%d exchange=%d\",\n            len(cached),\n            len(exchange),\n        )\n        \n        reconciled: list[Position] = []\n        discrepancies: list[str] = []\n\n        # Build lookup maps for O(1) access - O(n) + O(m)\n        cached_map: dict[str, Position] = {\n            pos.instrument_id.value: pos for pos in cached\n        }\n        exchange_map: dict[str, Position] = {\n            pos.instrument_id.value: pos for pos in exchange\n        }\n\n        # Process exchange positions (source of truth) - O(m)\n        for instrument_id, ex_pos in exchange_map.items():\n            ex_qty = ex_pos.quantity.as_decimal()\n            ex_side = ex_pos.side.value\n\n            if instrument_id in cached_map:\n                # Position exists in both cache and exchange\n                cached_pos = cached_map[instrument_id]\n                cached_qty = cached_pos.quantity.as_decimal()\n                cached_side = cached_pos.side.value\n\n                # Check for quantity mismatch\n                if cached_qty != ex_qty:\n                    msg = (\n                        f\"Quantity mismatch for {instrument_id}: \"\n                        f\"cached={cached_qty}, exchange={ex_qty}\"\n                    )\n                    discrepancies.append(msg)\n                    self._log.warning(msg)\n\n                # Check for side mismatch\n                if cached_side != ex_side:\n                    msg = (\n                        f\"Side mismatch for {instrument_id}: \"\n                        f\"cached={cached_side}, exchange={ex_side}\"\n                    )\n                    discrepancies.append(msg)\n                    self._log.warning(msg)\n                \n                if cached_qty == ex_qty and cached_side == ex_side:\n                    self._log.debug(\n                        \"Position matches: %s %s %s\",\n                        instrument_id,\n                        ex_side,\n                        ex_qty,\n                    )\n            else:\n                # External position (on exchange but not in cache)\n                msg = f\"External position detected: {instrument_id} {ex_side} {ex_qty}\"\n                discrepancies.append(msg)\n                self._log.warning(msg)\n\n            # Exchange is source of truth - add to reconciled\n            reconciled.append(ex_pos)\n\n        # Find positions closed on exchange (in cache but not on exchange) - O(n)\n        for instrument_id in cached_map:\n            if instrument_id not in exchange_map:\n                msg = (\n                    f\"Position closed on exchange: {instrument_id} \"\n                    f\"(missing from exchange)\"\n                )\n                discrepancies.append(msg)\n                self._log.warning(msg)\n\n        # Update discrepancy count\n        self._discrepancy_count = len(discrepancies)\n\n        self._log.info(\n            \"Reconciliation complete: reconciled=%d discrepancies=%d\",\n            len(reconciled),\n            len(discrepancies),\n        )\n\n        return reconciled, discrepancies\nEOF",
      "description": "Update provider.py with discrepancy_count property"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:37:45.311677",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && python -m pytest tests/unit/recovery/ tests/integration/recovery/ -v --tb=short 2>&1",
      "description": "Run all recovery tests"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:37:54.203911",
      "todo_count": 4
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:37:59.574905",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff check strategies/common/recovery/provider.py strategies/common/recovery/__init__.py tests/unit/recovery/conftest.py --fix 2>&1",
      "description": "Run ruff linter on modified files"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:38:05.565919",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff format strategies/common/recovery/provider.py strategies/common/recovery/__init__.py tests/unit/recovery/conftest.py 2>&1",
      "description": "Run ruff formatter on modified files"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:38:11.185751",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/provider.py"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:38:34.245975",
      "todo_count": 6
    },
    {
      "operation": "task",
      "timestamp": "2025-12-30T19:38:42.403386",
      "subagent_type": "test-runner",
      "prompt": "Run all recovery module tests (unit + integration) and provide a summary of results.\n\nCommands to ru..."
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:38:48.988867",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && python -m pytest tests/unit/recovery/ tests/integration/recovery/ -v --tb=short 2>&1",
      "description": "Run recovery module unit and integration tests"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:39:13.253671",
      "file_path": "/media/sam/1TB/nautilus_dev/specs/017-position-recovery/tasks.md"
    },
    {
      "operation": "edit",
      "timestamp": "2025-12-30T19:39:24.520713",
      "file_path": "/media/sam/1TB/nautilus_dev/specs/017-position-recovery/tasks.md",
      "old_string": "### Tests for FR-001\n\n- [ ] T011 [P] [FR1] Unit test for position loading from cache in `tests/unit/..."
    },
    {
      "operation": "edit",
      "timestamp": "2025-12-30T19:39:43.509409",
      "file_path": "/media/sam/1TB/nautilus_dev/specs/017-position-recovery/tasks.md",
      "old_string": "### Tests for FR-002\n\n- [ ] T020 [P] [FR2] Unit test for RecoverableStrategy base class in `tests/un..."
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:39:56.999031",
      "todo_count": 6
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:43:25.991357",
      "command": "git status",
      "description": "Show git working tree status"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:43:26.014939",
      "command": "git diff --stat",
      "description": "Show diff statistics"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:43:26.036083",
      "command": "git log --oneline -5",
      "description": "Show recent commits"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:43:33.043399",
      "command": "git diff specs/017-position-recovery/tasks.md",
      "description": "Show diff for tasks.md"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:43:42.927489",
      "command": "git add specs/017-position-recovery/tasks.md && git commit -m \"$(cat <<'EOF'\nMark FR-001 and FR-002 implementation tasks complete in tasks.md\n\nMVP implementation complete for Spec 017 Position Recovery:\n- FR-001: PositionRecoveryProvider with O(n+m) reconciliation (T011-T019)\n- FR-002: RecoverableStrategy base class with warmup pattern (T024-T031)\n\nAll 28 tests passing (18 unit + 10 integration).\n\n🤖 Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"",
      "description": "Commit tasks.md updates"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:43:50.612146",
      "command": "git log -1 --oneline",
      "description": "Show latest commit"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:43:54.361406",
      "command": "git status --short",
      "description": "Show git status short"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:51:26.071608",
      "todo_count": 2
    },
    {
      "operation": "task",
      "timestamp": "2025-12-30T19:51:44.786999",
      "subagent_type": "nautilus-coder",
      "prompt": "Create unit tests for FR-002 (RecoverableStrategy) in Spec 017 Position Recovery.\n\n**Tasks:**\n- T020..."
    },
    {
      "operation": "task",
      "timestamp": "2025-12-30T19:51:44.793590",
      "subagent_type": "nautilus-coder",
      "prompt": "Create integration test for FR-002 (Strategy Recovery) in Spec 017 Position Recovery.\n\n**Task:** T02..."
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:51:52.340195",
      "todo_count": 6
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:51:53.449273",
      "todo_count": 7
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:51:58.958763",
      "file_path": "/media/sam/1TB/nautilus_dev/tests/integration/recovery/test_cold_start.py"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:51:58.967978",
      "file_path": "/media/sam/1TB/nautilus_dev/tests/integration/recovery/test_warm_start.py"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:51:58.975541",
      "file_path": "/media/sam/1TB/nautilus_dev/tests/integration/recovery/conftest.py"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:51:58.981579",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/recoverable_strategy.py"
    },
    {
      "operation": "task",
      "timestamp": "2025-12-30T19:51:59.483495",
      "subagent_type": "nautilus-coder",
      "prompt": "Create RecoveryEventEmitter and RecoveryStateManager implementations for Spec 017 Position Recovery ..."
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:00.267545",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/recoverable_strategy.py"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:00.273970",
      "file_path": "/media/sam/1TB/nautilus_dev/tests/unit/recovery/conftest.py"
    },
    {
      "operation": "taskoutput",
      "timestamp": "2025-12-30T19:52:06.848684",
      "task_id": "a099a1c",
      "block": false,
      "timeout": 30000
    },
    {
      "operation": "taskoutput",
      "timestamp": "2025-12-30T19:52:06.862598",
      "task_id": "a590ba9",
      "block": false,
      "timeout": 30000
    },
    {
      "operation": "taskoutput",
      "timestamp": "2025-12-30T19:52:06.871026",
      "task_id": "ab80bed",
      "block": false,
      "timeout": 30000
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:52:07.137644",
      "todo_count": 6
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:07.292171",
      "file_path": "/media/sam/1TB/nautilus_dev/specs/017-position-recovery"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:07.301643",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/config.py"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:07.307849",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/models.py"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:52:09.391077",
      "todo_count": 6
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:14.046767",
      "file_path": "/media/sam/1TB/nautilus_dev/specs/017-position-recovery/contracts/recovery_events.py"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:14.055383",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/models.py"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:14.079981",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/__init__.py"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:14.083992",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/events.py"
    },
    {
      "operation": "taskoutput",
      "timestamp": "2025-12-30T19:52:14.919354",
      "task_id": "a099a1c",
      "block": true,
      "timeout": 180000
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:52:15.952792",
      "todo_count": 7
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:21.698878",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/config.py"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:21.709048",
      "file_path": "/media/sam/1TB/nautilus_dev/strategies/common/recovery/provider.py"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:52:22.525109",
      "command": "ls -la /media/sam/1TB/nautilus_dev/tests/unit/recovery/ 2>/dev/null || echo \"Directory does not exist\"",
      "description": "List unit recovery test directory"
    },
    {
      "operation": "read",
      "timestamp": "2025-12-30T19:52:28.655995",
      "file_path": "/media/sam/1TB/nautilus_dev/tests/unit/recovery/test_position_loading.py"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:52:30.009030",
      "todo_count": 6
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:53:15.965449",
      "command": "cat > /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_recoverable_strategy.py << 'EOF'\n\"\"\"Unit tests for RecoverableStrategy base class (FR-002 - T020).\n\nTests:\n- RecoverableStrategyConfig validation\n- on_start() position detection flow\n- on_position_recovered() hook is called\n- _handle_recovered_position() updates state\n- is_warming_up / is_ready properties\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom decimal import Decimal\nfrom unittest.mock import MagicMock, call, patch\n\nimport pytest\n\nfrom strategies.common.recovery.config import RecoveryConfig\nfrom strategies.common.recovery.models import RecoveryState, RecoveryStatus\n\n\n@pytest.mark.recovery\nclass TestRecoverableStrategyConfig:\n    \"\"\"Tests for RecoverableStrategyConfig validation.\"\"\"\n\n    def test_config_valid_minimal(self):\n        \"\"\"Test creating config with minimal required fields.\"\"\"\n        from strategies.common.recovery.recoverable_strategy import (\n            RecoverableStrategyConfig,\n        )\n\n        config = RecoverableStrategyConfig(\n            instrument_id=\"BTCUSDT-PERP.BINANCE\",\n            bar_type=\"BTCUSDT-PERP.BINANCE-1-MINUTE-LAST-EXTERNAL\",\n        )\n\n        assert config.instrument_id == \"BTCUSDT-PERP.BINANCE\"\n        assert config.bar_type == \"BTCUSDT-PERP.BINANCE-1-MINUTE-LAST-EXTERNAL\"\n        assert config.recovery is None\n\n    def test_config_valid_with_recovery(self, recovery_config):\n        \"\"\"Test creating config with recovery settings.\"\"\"\n        from strategies.common.recovery.recoverable_strategy import (\n            RecoverableStrategyConfig,\n        )\n\n        config = RecoverableStrategyConfig(\n            instrument_id=\"BTCUSDT-PERP.BINANCE\",\n            bar_type=\"BTCUSDT-PERP.BINANCE-1-MINUTE-LAST-EXTERNAL\",\n            recovery=recovery_config,\n        )\n\n        assert config.recovery is not None\n        assert config.recovery.recovery_enabled is True\n        assert config.recovery.warmup_lookback_days == 2\n\n    def test_config_frozen(self, recovery_config):\n        \"\"\"Test that config is immutable (frozen).\"\"\"\n        from strategies.common.recovery.recoverable_strategy import (\n            RecoverableStrategyConfig,\n        )\n\n        config = RecoverableStrategyConfig(\n            instrument_id=\"BTCUSDT-PERP.BINANCE\",\n            bar_type=\"BTCUSDT-PERP.BINANCE-1-MINUTE-LAST-EXTERNAL\",\n            recovery=recovery_config,\n        )\n\n        # Attempting to modify should raise an error\n        with pytest.raises(Exception):  # ValidationError or AttributeError\n            config.instrument_id = \"ETHUSDT-PERP.BINANCE\"\n\n\n@pytest.mark.recovery\nclass TestRecoverableStrategyInit:\n    \"\"\"Tests for RecoverableStrategy initialization.\"\"\"\n\n    def test_init_sets_instrument_id(self, recovery_config):\n        \"\"\"Test that __init__ sets instrument_id from config.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        from strategies.common.recovery.recoverable_strategy import (\n            RecoverableStrategy,\n            RecoverableStrategyConfig,\n        )\n\n        config = RecoverableStrategyConfig(\n            instrument_id=\"BTCUSDT-PERP.BINANCE\",\n            bar_type=\"BTCUSDT-PERP.BINANCE-1-MINUTE-LAST-EXTERNAL\",\n            recovery=recovery_config,\n        )\n\n        # RecoverableStrategy inherits from Strategy which needs more setup\n        # We test the config parsing directly\n        instrument_id = InstrumentId.from_str(config.instrument_id)\n        assert str(instrument_id) == \"BTCUSDT-PERP.BINANCE\"\n\n    def test_init_default_recovery_state(self):\n        \"\"\"Test that initial recovery state is PENDING with zeros.\"\"\"\n        state = RecoveryState()\n\n        assert state.status == RecoveryStatus.PENDING\n        assert state.positions_recovered == 0\n        assert state.indicators_warmed is False\n        assert state.orders_reconciled is False\n\n\n@pytest.mark.recovery\nclass TestRecoverableStrategyOnStart:\n    \"\"\"Tests for on_start() position detection flow.\"\"\"\n\n    @pytest.fixture\n    def mock_strategy(self, mock_cache, mock_clock, mock_logger, recovery_config):\n        \"\"\"Create a mock RecoverableStrategy for testing on_start flow.\"\"\"\n        strategy = MagicMock()\n        strategy.cache = mock_cache\n        strategy.clock = mock_clock\n        strategy.log = mock_logger\n        strategy.recovery_config = recovery_config\n        strategy.recovery_state = RecoveryState()\n        strategy._warmup_complete = False\n        strategy._warmup_bars_processed = 0\n        strategy._warmup_start_ns = None\n        strategy._recovered_positions = []\n\n        # Setup instrument mock\n        mock_instrument = MagicMock()\n        mock_instrument.id = MagicMock()\n        mock_instrument.id.value = \"BTCUSDT-PERP.BINANCE\"\n        mock_cache.instrument.return_value = mock_instrument\n        strategy.instrument = None\n\n        return strategy\n\n    def test_on_start_loads_instrument_from_cache(\n        self, mock_strategy, mock_cache\n    ):\n        \"\"\"Test that on_start loads instrument from cache.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        instrument_id = InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n\n        # Simulate on_start behavior\n        mock_strategy.instrument = mock_cache.instrument(instrument_id)\n\n        mock_cache.instrument.assert_called_with(instrument_id)\n        assert mock_strategy.instrument is not None\n\n    def test_on_start_stops_if_instrument_not_found(\n        self, mock_strategy, mock_cache, mock_logger\n    ):\n        \"\"\"Test that on_start stops strategy if instrument not in cache.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        mock_cache.instrument.return_value = None\n        instrument_id = InstrumentId.from_str(\"UNKNOWN-PERP.BINANCE\")\n\n        # Simulate on_start instrument check\n        instrument = mock_cache.instrument(instrument_id)\n\n        if instrument is None:\n            mock_logger.error(f\"Instrument {instrument_id} not found in cache\")\n            mock_strategy.stop = MagicMock()\n            mock_strategy.stop()\n\n        mock_logger.error.assert_called()\n        mock_strategy.stop.assert_called_once()\n\n    def test_on_start_updates_recovery_state_to_in_progress(\n        self, mock_strategy, mock_clock\n    ):\n        \"\"\"Test that on_start updates recovery state to IN_PROGRESS.\"\"\"\n        # Simulate on_start behavior\n        mock_strategy.recovery_state = RecoveryState(\n            status=RecoveryStatus.IN_PROGRESS,\n            ts_started=mock_clock.timestamp_ns(),\n        )\n\n        assert mock_strategy.recovery_state.status == RecoveryStatus.IN_PROGRESS\n        assert mock_strategy.recovery_state.ts_started == 1704153600000000000\n\n\n@pytest.mark.recovery\nclass TestPositionRecoveryHooks:\n    \"\"\"Tests for position recovery hooks and state updates.\"\"\"\n\n    def test_on_position_recovered_hook_is_callable(self):\n        \"\"\"Test that on_position_recovered is a valid hook method.\"\"\"\n        from strategies.common.recovery.recoverable_strategy import (\n            RecoverableStrategy,\n        )\n\n        # Verify the method exists and is callable\n        assert hasattr(RecoverableStrategy, \"on_position_recovered\")\n        assert callable(getattr(RecoverableStrategy, \"on_position_recovered\"))\n\n    def test_handle_recovered_position_updates_state(\n        self, mock_btc_position\n    ):\n        \"\"\"Test that _handle_recovered_position updates recovery state.\"\"\"\n        state = RecoveryState(\n            status=RecoveryStatus.IN_PROGRESS,\n            positions_recovered=0,\n        )\n\n        # Simulate _handle_recovered_position behavior\n        recovered_positions = []\n        recovered_positions.append(mock_btc_position)\n\n        new_state = RecoveryState(\n            status=state.status,\n            positions_recovered=state.positions_recovered + 1,\n            indicators_warmed=state.indicators_warmed,\n            orders_reconciled=state.orders_reconciled,\n            ts_started=state.ts_started,\n        )\n\n        assert new_state.positions_recovered == 1\n        assert len(recovered_positions) == 1\n\n    def test_handle_recovered_position_calls_hook(\n        self, mock_btc_position\n    ):\n        \"\"\"Test that _handle_recovered_position calls on_position_recovered hook.\"\"\"\n        on_position_recovered_called = False\n        recovered_position = None\n\n        def mock_on_position_recovered(position):\n            nonlocal on_position_recovered_called, recovered_position\n            on_position_recovered_called = True\n            recovered_position = position\n\n        # Simulate the hook call\n        mock_on_position_recovered(mock_btc_position)\n\n        assert on_position_recovered_called is True\n        assert recovered_position == mock_btc_position\n\n    def test_handle_multiple_recovered_positions(\n        self, mock_btc_position, mock_eth_position\n    ):\n        \"\"\"Test handling multiple recovered positions updates count correctly.\"\"\"\n        recovered_positions = []\n        positions_recovered_count = 0\n\n        # Simulate recovering multiple positions\n        for position in [mock_btc_position, mock_eth_position]:\n            recovered_positions.append(position)\n            positions_recovered_count += 1\n\n        final_state = RecoveryState(\n            status=RecoveryStatus.IN_PROGRESS,\n            positions_recovered=positions_recovered_count,\n        )\n\n        assert final_state.positions_recovered == 2\n        assert len(recovered_positions) == 2\n\n\n@pytest.mark.recovery\nclass TestRecoverableStrategyProperties:\n    \"\"\"Tests for is_warming_up and is_ready properties.\"\"\"\n\n    def test_is_warming_up_true_before_warmup_complete(self):\n        \"\"\"Test is_warming_up returns True when warmup not complete.\"\"\"\n        # Simulate strategy state before warmup\n        warmup_complete = False\n        is_warming_up = not warmup_complete\n\n        assert is_warming_up is True\n\n    def test_is_warming_up_false_after_warmup_complete(self):\n        \"\"\"Test is_warming_up returns False after warmup completes.\"\"\"\n        # Simulate strategy state after warmup\n        warmup_complete = True\n        is_warming_up = not warmup_complete\n\n        assert is_warming_up is False\n\n    def test_is_ready_requires_warmup_complete(self):\n        \"\"\"Test is_ready requires warmup_complete to be True.\"\"\"\n        warmup_complete = False\n        state = RecoveryState(status=RecoveryStatus.COMPLETED)\n\n        is_ready = warmup_complete and state.status == RecoveryStatus.COMPLETED\n\n        assert is_ready is False\n\n    def test_is_ready_requires_status_completed(self):\n        \"\"\"Test is_ready requires recovery status COMPLETED.\"\"\"\n        warmup_complete = True\n        state = RecoveryState(status=RecoveryStatus.IN_PROGRESS)\n\n        is_ready = warmup_complete and state.status == RecoveryStatus.COMPLETED\n\n        assert is_ready is False\n\n    def test_is_ready_true_when_both_conditions_met(self):\n        \"\"\"Test is_ready returns True when both conditions met.\"\"\"\n        warmup_complete = True\n        state = RecoveryState(status=RecoveryStatus.COMPLETED)\n\n        is_ready = warmup_complete and state.status == RecoveryStatus.COMPLETED\n\n        assert is_ready is True\n\n    def test_recovered_positions_count_property(self):\n        \"\"\"Test recovered_positions_count returns correct count.\"\"\"\n        recovered_positions = [MagicMock(), MagicMock(), MagicMock()]\n\n        # Simulate property\n        recovered_positions_count = len(recovered_positions)\n\n        assert recovered_positions_count == 3\n\n\n@pytest.mark.recovery\nclass TestDetectRecoveredPositions:\n    \"\"\"Tests for _detect_recovered_positions method.\"\"\"\n\n    def test_detect_positions_filters_open_only(\n        self, mock_cache\n    ):\n        \"\"\"Test that only open positions are handled.\"\"\"\n        # Create mix of open and closed positions\n        open_pos = MagicMock()\n        open_pos.is_open = True\n        open_pos.instrument_id = MagicMock()\n        open_pos.instrument_id.value = \"BTCUSDT-PERP.BINANCE\"\n\n        closed_pos = MagicMock()\n        closed_pos.is_open = False\n\n        mock_cache.positions.return_value = [open_pos, closed_pos]\n\n        # Simulate _detect_recovered_positions logic\n        positions = mock_cache.positions()\n        handled_positions = []\n        for position in positions:\n            if position.is_open:\n                handled_positions.append(position)\n\n        assert len(handled_positions) == 1\n        assert handled_positions[0].is_open is True\n\n    def test_detect_positions_empty_cache(self, mock_cache):\n        \"\"\"Test handling empty positions from cache.\"\"\"\n        mock_cache.positions.return_value = []\n\n        positions = mock_cache.positions()\n        handled_positions = [p for p in positions if p.is_open]\n\n        assert len(handled_positions) == 0\n\n    def test_detect_positions_by_instrument_id(self, mock_cache):\n        \"\"\"Test that positions are filtered by instrument_id.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        btc_pos = MagicMock()\n        btc_pos.is_open = True\n        btc_pos.instrument_id = InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n\n        # Simulate calling with instrument_id filter\n        mock_cache.positions.return_value = [btc_pos]\n\n        positions = mock_cache.positions(\n            instrument_id=InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n        )\n\n        mock_cache.positions.assert_called_with(\n            instrument_id=InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n        )\n        assert len(positions) == 1\nEOF\necho \"Created test_recoverable_strategy.py\"",
      "description": "Create T020 test file for RecoverableStrategy"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:53:25.301519",
      "todo_count": 7
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:53:49.830814",
      "command": "cat > /media/sam/1TB/nautilus_dev/tests/integration/recovery/test_strategy_recovery.py << 'EOF'\n\"\"\"Integration test for strategy recovery (FR-002).\n\nTests that RecoverableStrategy correctly:\n- Starts with recovered positions from cache\n- Requests historical warmup data\n- Calls on_warmup_complete() hook\n- Blocks trading during warmup (is_warming_up)\n- Reports is_ready after warmup completes\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom datetime import datetime, timedelta, timezone\nfrom decimal import Decimal\nfrom unittest.mock import MagicMock, call, patch\n\nimport pytest\n\nfrom strategies.common.recovery.config import RecoveryConfig\nfrom strategies.common.recovery.models import RecoveryStatus\nfrom strategies.common.recovery.recoverable_strategy import (\n    RecoverableStrategy,\n    RecoverableStrategyConfig,\n)\n\n\n@pytest.fixture\ndef mock_instrument():\n    \"\"\"Create a mock instrument for testing.\"\"\"\n    instrument = MagicMock()\n    instrument.id.value = \"BTCUSDT-PERP.BINANCE\"\n    return instrument\n\n\n@pytest.fixture\ndef mock_position():\n    \"\"\"Create a mock open position for recovery testing.\"\"\"\n    position = MagicMock()\n    position.instrument_id.value = \"BTCUSDT-PERP.BINANCE\"\n    position.side.value = \"LONG\"\n    position.quantity.as_decimal.return_value = Decimal(\"1.5\")\n    position.avg_px_open = Decimal(\"42000.00\")\n    position.is_open = True\n    return position\n\n\n@pytest.fixture\ndef mock_bar():\n    \"\"\"Create a mock bar for warmup testing.\"\"\"\n    bar = MagicMock()\n    bar.ts_event = 1704067200000000000  # 2024-01-01 00:00:00 UTC\n    bar.close = Decimal(\"42500.00\")\n    bar.open = Decimal(\"42000.00\")\n    bar.high = Decimal(\"42700.00\")\n    bar.low = Decimal(\"41800.00\")\n    bar.volume = Decimal(\"100.0\")\n    return bar\n\n\n@pytest.fixture\ndef strategy_config():\n    \"\"\"Create a RecoverableStrategyConfig for testing.\"\"\"\n    return RecoverableStrategyConfig(\n        instrument_id=\"BTCUSDT-PERP.BINANCE\",\n        bar_type=\"BTCUSDT-PERP.BINANCE-1-MINUTE-LAST-EXTERNAL\",\n        recovery=RecoveryConfig(\n            trader_id=\"TESTER-001\",\n            recovery_enabled=True,\n            warmup_lookback_days=2,\n            startup_delay_secs=10.0,\n            max_recovery_time_secs=30.0,\n        ),\n    )\n\n\n@pytest.fixture\ndef strategy_config_disabled():\n    \"\"\"Create a RecoverableStrategyConfig with recovery disabled.\"\"\"\n    return RecoverableStrategyConfig(\n        instrument_id=\"BTCUSDT-PERP.BINANCE\",\n        bar_type=\"BTCUSDT-PERP.BINANCE-1-MINUTE-LAST-EXTERNAL\",\n        recovery=RecoveryConfig(\n            trader_id=\"TESTER-001\",\n            recovery_enabled=False,\n            warmup_lookback_days=2,\n        ),\n    )\n\n\nclass TestableRecoverableStrategy(RecoverableStrategy):\n    \"\"\"Testable subclass that tracks hook calls.\"\"\"\n\n    def __init__(self, config: RecoverableStrategyConfig) -> None:\n        super().__init__(config)\n        self.position_recovered_calls: list = []\n        self.historical_data_calls: list = []\n        self.warmup_complete_called: bool = False\n\n    def on_position_recovered(self, position) -> None:\n        \"\"\"Track position recovered calls.\"\"\"\n        self.position_recovered_calls.append(position)\n\n    def on_historical_data(self, bar) -> None:\n        \"\"\"Track historical data processing calls.\"\"\"\n        self.historical_data_calls.append(bar)\n\n    def on_warmup_complete(self) -> None:\n        \"\"\"Track warmup complete calls.\"\"\"\n        self.warmup_complete_called = True\n\n\n@pytest.mark.integration\n@pytest.mark.recovery\nclass TestStrategyRecovery:\n    \"\"\"Integration tests for RecoverableStrategy (FR-002).\"\"\"\n\n    def test_strategy_starts_with_recovered_position(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        mock_position,\n        strategy_config,\n    ):\n        \"\"\"Test strategy detects and processes recovered position from cache.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = [mock_position]\n        mock_cache.orders_open.return_value = []\n\n        strategy = TestableRecoverableStrategy(strategy_config)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        # Patch request_bars to avoid actual data request\n        with patch.object(strategy, \"request_bars\"):\n            with patch.object(strategy, \"subscribe_bars\"):\n                strategy.on_start()\n\n        # Verify position was recovered\n        assert strategy.recovered_positions_count == 1\n        assert len(strategy.position_recovered_calls) == 1\n        assert strategy.position_recovered_calls[0] == mock_position\n        assert strategy.recovery_state.positions_recovered == 1\n\n    def test_strategy_requests_warmup_data(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test strategy requests historical bars for indicator warmup.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = TestableRecoverableStrategy(strategy_config)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        request_bars_mock = MagicMock()\n\n        with patch.object(strategy, \"request_bars\", request_bars_mock):\n            with patch.object(strategy, \"subscribe_bars\"):\n                strategy.on_start()\n\n        # Verify request_bars was called with correct parameters\n        assert request_bars_mock.called\n        call_kwargs = request_bars_mock.call_args\n        assert call_kwargs.kwargs[\"bar_type\"] == strategy.bar_type\n\n        # Verify start time is approximately warmup_lookback_days ago\n        expected_start = mock_clock.utc_now.return_value - timedelta(days=2)\n        assert call_kwargs.kwargs[\"start\"] == expected_start\n\n    def test_warmup_data_processed_and_complete_called(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        mock_bar,\n        strategy_config,\n    ):\n        \"\"\"Test historical data is processed and on_warmup_complete is called.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = TestableRecoverableStrategy(strategy_config)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        # Create multiple warmup bars\n        bars = []\n        for i in range(5):\n            bar = MagicMock()\n            bar.ts_event = 1704067200000000000 + (i * 60_000_000_000)  # 1 min apart\n            bars.append(bar)\n\n        # Start strategy (with patched request_bars)\n        with patch.object(strategy, \"request_bars\"):\n            with patch.object(strategy, \"subscribe_bars\"):\n                strategy.on_start()\n\n        # Simulate warmup data callback\n        strategy._on_warmup_data_received(bars)\n\n        # Verify all bars were processed\n        assert len(strategy.historical_data_calls) == 5\n        assert strategy._warmup_bars_processed == 5\n\n        # Verify on_warmup_complete was called\n        assert strategy.warmup_complete_called\n\n    def test_strategy_is_ready_after_warmup(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test strategy is_ready returns True after warmup completes.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = TestableRecoverableStrategy(strategy_config)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        # Start strategy\n        with patch.object(strategy, \"request_bars\"):\n            with patch.object(strategy, \"subscribe_bars\"):\n                strategy.on_start()\n\n        # Before warmup complete\n        assert strategy.is_warming_up\n        assert not strategy.is_ready\n\n        # Simulate warmup completion\n        strategy._on_warmup_data_received([MagicMock(ts_event=1704067200000000000)])\n\n        # After warmup complete\n        assert not strategy.is_warming_up\n        assert strategy.is_ready\n        assert strategy.recovery_state.status == RecoveryStatus.COMPLETED\n\n    def test_strategy_blocks_trading_during_warmup(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test is_warming_up is True during warmup phase.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = TestableRecoverableStrategy(strategy_config)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        # Start strategy\n        with patch.object(strategy, \"request_bars\"):\n            with patch.object(strategy, \"subscribe_bars\"):\n                strategy.on_start()\n\n        # Strategy should be warming up (blocking trades)\n        assert strategy.is_warming_up\n        assert not strategy._warmup_complete\n        assert strategy.recovery_state.status == RecoveryStatus.IN_PROGRESS\n\n    def test_recovery_state_transitions(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        mock_position,\n        strategy_config,\n    ):\n        \"\"\"Test recovery state transitions through lifecycle.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = [mock_position]\n        mock_cache.orders_open.return_value = []\n\n        strategy = TestableRecoverableStrategy(strategy_config)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        # Initial state (before on_start)\n        assert strategy.recovery_state.status == RecoveryStatus.PENDING\n\n        # Start strategy\n        with patch.object(strategy, \"request_bars\"):\n            with patch.object(strategy, \"subscribe_bars\"):\n                strategy.on_start()\n\n        # After on_start (in progress)\n        assert strategy.recovery_state.status == RecoveryStatus.IN_PROGRESS\n        assert strategy.recovery_state.positions_recovered == 1\n        assert not strategy.recovery_state.indicators_warmed\n\n        # After warmup complete\n        strategy._on_warmup_data_received([MagicMock(ts_event=1704067200000000000)])\n\n        # Final state\n        assert strategy.recovery_state.status == RecoveryStatus.COMPLETED\n        assert strategy.recovery_state.indicators_warmed\n        assert strategy.recovery_state.orders_reconciled\n        assert strategy.recovery_state.is_complete\n\n    def test_empty_warmup_data_still_completes(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test warmup completes even with no historical data.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = TestableRecoverableStrategy(strategy_config)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        # Start strategy\n        with patch.object(strategy, \"request_bars\"):\n            with patch.object(strategy, \"subscribe_bars\"):\n                strategy.on_start()\n\n        # Simulate empty warmup data\n        strategy._on_warmup_data_received([])\n\n        # Should still complete warmup\n        assert strategy.warmup_complete_called\n        assert strategy.is_ready\n        assert strategy._warmup_bars_processed == 0\n\n    def test_recovery_disabled_skips_position_detection(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        mock_position,\n        strategy_config_disabled,\n    ):\n        \"\"\"Test position detection is skipped when recovery disabled.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = [mock_position]\n\n        strategy = TestableRecoverableStrategy(strategy_config_disabled)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        # Start strategy\n        with patch.object(strategy, \"request_bars\"):\n            with patch.object(strategy, \"subscribe_bars\"):\n                strategy.on_start()\n\n        # Position detection should be skipped\n        assert strategy.recovered_positions_count == 0\n        assert len(strategy.position_recovered_calls) == 0\n\n    def test_multiple_positions_recovered(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test multiple positions are recovered correctly.\"\"\"\n        # Setup multiple positions\n        positions = []\n        for i, qty in enumerate([Decimal(\"1.0\"), Decimal(\"2.0\")]):\n            pos = MagicMock()\n            pos.instrument_id = mock_instrument.id\n            pos.instrument_id.value = \"BTCUSDT-PERP.BINANCE\"\n            pos.side.value = \"LONG\"\n            pos.quantity = qty\n            pos.avg_px_open = Decimal(\"42000.00\")\n            pos.is_open = True\n            positions.append(pos)\n\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = positions\n        mock_cache.orders_open.return_value = []\n\n        strategy = TestableRecoverableStrategy(strategy_config)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        # Start strategy\n        with patch.object(strategy, \"request_bars\"):\n            with patch.object(strategy, \"subscribe_bars\"):\n                strategy.on_start()\n\n        # Both positions should be recovered\n        assert strategy.recovered_positions_count == 2\n        assert len(strategy.position_recovered_calls) == 2\n        assert strategy.recovery_state.positions_recovered == 2\n\n    def test_closed_positions_not_recovered(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test closed positions are not processed as recovered.\"\"\"\n        # Setup closed position\n        closed_position = MagicMock()\n        closed_position.instrument_id.value = \"BTCUSDT-PERP.BINANCE\"\n        closed_position.is_open = False\n\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = [closed_position]\n        mock_cache.orders_open.return_value = []\n\n        strategy = TestableRecoverableStrategy(strategy_config)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        # Start strategy\n        with patch.object(strategy, \"request_bars\"):\n            with patch.object(strategy, \"subscribe_bars\"):\n                strategy.on_start()\n\n        # Closed position should not be recovered\n        assert strategy.recovered_positions_count == 0\n        assert len(strategy.position_recovered_calls) == 0\n\n    def test_instrument_not_found_stops_strategy(\n        self,\n        mock_cache,\n        mock_clock,\n        strategy_config,\n    ):\n        \"\"\"Test strategy stops if instrument not found in cache.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = None\n\n        strategy = TestableRecoverableStrategy(strategy_config)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        stop_mock = MagicMock()\n        strategy.stop = stop_mock\n\n        # Start strategy\n        strategy.on_start()\n\n        # Strategy should call stop due to missing instrument\n        assert stop_mock.called\n\n    def test_warmup_bars_sorted_by_timestamp(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test warmup bars are processed in chronological order.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = TestableRecoverableStrategy(strategy_config)\n        strategy._cache = mock_cache\n        strategy._clock = mock_clock\n        strategy._log = MagicMock()\n\n        # Create bars in reverse order\n        bars = []\n        timestamps = [1704067260000000000, 1704067200000000000, 1704067320000000000]\n        for ts in timestamps:\n            bar = MagicMock()\n            bar.ts_event = ts\n            bars.append(bar)\n\n        # Start strategy\n        with patch.object(strategy, \"request_bars\"):\n            with patch.object(strategy, \"subscribe_bars\"):\n                strategy.on_start()\n\n        # Process warmup data\n        strategy._on_warmup_data_received(bars)\n\n        # Verify bars were processed in sorted order (oldest first)\n        processed_timestamps = [b.ts_event for b in strategy.historical_data_calls]\n        assert processed_timestamps == sorted(timestamps)\nEOF",
      "description": "Create test_strategy_recovery.py integration test"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:53:56.877815",
      "command": "cat > /media/sam/1TB/nautilus_dev/strategies/common/recovery/event_emitter.py << 'EOF'\n\"\"\"Recovery Event Emitter (Spec 017).\n\nThis module implements the RecoveryEventEmitter for emitting recovery events.\nEvents are used for logging, monitoring, and alerting.\n\nImplementation Note:\n    MVP uses logging-based emission. Future versions may integrate with\n    NautilusTrader message bus for pub/sub event distribution.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport time\nfrom typing import TYPE_CHECKING, Callable\n\nfrom strategies.common.recovery.events import (\n    IndicatorsReadyEvent,\n    IndicatorsWarmingEvent,\n    PositionDiscrepancyEvent,\n    PositionLoadedEvent,\n    PositionReconciledEvent,\n    RecoveryCompletedEvent,\n    RecoveryFailedEvent,\n    RecoveryStartedEvent,\n    RecoveryTimeoutEvent,\n)\n\nif TYPE_CHECKING:\n    from pydantic import BaseModel\n\n\n# Module logger\n_log = logging.getLogger(__name__)\n\n\ndef _now_ns() -> int:\n    \"\"\"Get current time in nanoseconds.\"\"\"\n    return int(time.time() * 1_000_000_000)\n\n\nclass RecoveryEventEmitter:\n    \"\"\"Emitter for recovery events.\n\n    Provides methods to emit recovery events for monitoring and alerting.\n    MVP implementation logs events; can be extended for message bus integration.\n\n    Attributes:\n        trader_id: Trader identifier for all emitted events.\n        logger: Logger instance for event output.\n\n    Example:\n        >>> emitter = RecoveryEventEmitter(trader_id=\"TRADER-001\")\n        >>> emitter.emit_recovery_started(cached_positions_count=3)\n        >>> emitter.emit_position_loaded(\n        ...     instrument_id=\"BTCUSDT-PERP.BINANCE\",\n        ...     side=\"LONG\",\n        ...     quantity=\"1.5\",\n        ...     avg_entry_price=\"42000.00\",\n        ... )\n        >>> emitter.emit_recovery_completed(\n        ...     positions_recovered=3,\n        ...     discrepancies_resolved=1,\n        ...     total_duration_ms=1500.5,\n        ...     strategies_ready=2,\n        ... )\n    \"\"\"\n\n    def __init__(\n        self,\n        trader_id: str,\n        logger: logging.Logger | None = None,\n        on_event: Callable[[BaseModel], None] | None = None,\n    ) -> None:\n        \"\"\"Initialize the RecoveryEventEmitter.\n\n        Args:\n            trader_id: Trader identifier for all emitted events.\n            logger: Optional custom logger. If None, uses module logger.\n            on_event: Optional callback invoked for each emitted event.\n                     Useful for message bus integration or testing.\n        \"\"\"\n        self._trader_id = trader_id\n        self._log = logger or _log\n        self._on_event = on_event\n\n    @property\n    def trader_id(self) -> str:\n        \"\"\"Trader identifier for all emitted events.\"\"\"\n        return self._trader_id\n\n    def _emit(self, event: BaseModel) -> None:\n        \"\"\"Emit an event via logging and optional callback.\n\n        Args:\n            event: The Pydantic event model to emit.\n        \"\"\"\n        # Log the event as JSON for structured logging\n        self._log.info(\n            \"Recovery event: %s\",\n            event.model_dump_json(),\n        )\n\n        # Invoke callback if registered\n        if self._on_event is not None:\n            self._on_event(event)\n\n    def emit_recovery_started(\n        self,\n        cached_positions_count: int,\n        ts_event: int | None = None,\n    ) -> RecoveryStartedEvent:\n        \"\"\"Emit RecoveryStartedEvent when recovery begins.\n\n        Args:\n            cached_positions_count: Number of positions in cache.\n            ts_event: Event timestamp (nanoseconds). If None, uses current time.\n\n        Returns:\n            The emitted event.\n        \"\"\"\n        event = RecoveryStartedEvent(\n            trader_id=self._trader_id,\n            ts_event=ts_event or _now_ns(),\n            cached_positions_count=cached_positions_count,\n        )\n        self._emit(event)\n        return event\n\n    def emit_position_loaded(\n        self,\n        instrument_id: str,\n        side: str,\n        quantity: str,\n        avg_entry_price: str,\n        ts_event: int | None = None,\n    ) -> PositionLoadedEvent:\n        \"\"\"Emit PositionLoadedEvent when a position is loaded from cache.\n\n        Args:\n            instrument_id: Position instrument ID.\n            side: Position side (LONG/SHORT).\n            quantity: Position quantity as string.\n            avg_entry_price: Average entry price as string.\n            ts_event: Event timestamp (nanoseconds). If None, uses current time.\n\n        Returns:\n            The emitted event.\n        \"\"\"\n        event = PositionLoadedEvent(\n            trader_id=self._trader_id,\n            ts_event=ts_event or _now_ns(),\n            instrument_id=instrument_id,\n            side=side,\n            quantity=quantity,\n            avg_entry_price=avg_entry_price,\n        )\n        self._emit(event)\n        return event\n\n    def emit_position_reconciled(\n        self,\n        instrument_id: str,\n        cached_quantity: str,\n        exchange_quantity: str,\n        reconciled: bool,\n        ts_event: int | None = None,\n    ) -> PositionReconciledEvent:\n        \"\"\"Emit PositionReconciledEvent when a position is reconciled.\n\n        Args:\n            instrument_id: Position instrument ID.\n            cached_quantity: Quantity from cache.\n            exchange_quantity: Quantity from exchange.\n            reconciled: Whether reconciliation succeeded.\n            ts_event: Event timestamp (nanoseconds). If None, uses current time.\n\n        Returns:\n            The emitted event.\n        \"\"\"\n        event = PositionReconciledEvent(\n            trader_id=self._trader_id,\n            ts_event=ts_event or _now_ns(),\n            instrument_id=instrument_id,\n            cached_quantity=cached_quantity,\n            exchange_quantity=exchange_quantity,\n            reconciled=reconciled,\n        )\n        self._emit(event)\n        return event\n\n    def emit_position_discrepancy(\n        self,\n        instrument_id: str,\n        resolution: str,\n        cached_side: str | None = None,\n        exchange_side: str | None = None,\n        cached_quantity: str | None = None,\n        exchange_quantity: str | None = None,\n        ts_event: int | None = None,\n    ) -> PositionDiscrepancyEvent:\n        \"\"\"Emit PositionDiscrepancyEvent when cache and exchange differ.\n\n        Args:\n            instrument_id: Position instrument ID.\n            resolution: How discrepancy was resolved.\n            cached_side: Side from cache (optional).\n            exchange_side: Side from exchange (optional).\n            cached_quantity: Quantity from cache (optional).\n            exchange_quantity: Quantity from exchange (optional).\n            ts_event: Event timestamp (nanoseconds). If None, uses current time.\n\n        Returns:\n            The emitted event.\n        \"\"\"\n        event = PositionDiscrepancyEvent(\n            trader_id=self._trader_id,\n            ts_event=ts_event or _now_ns(),\n            instrument_id=instrument_id,\n            cached_side=cached_side,\n            exchange_side=exchange_side,\n            cached_quantity=cached_quantity,\n            exchange_quantity=exchange_quantity,\n            resolution=resolution,\n        )\n        self._emit(event)\n        return event\n\n    def emit_indicators_warming(\n        self,\n        strategy_id: str,\n        indicator_count: int,\n        lookback_days: int,\n        ts_event: int | None = None,\n    ) -> IndicatorsWarmingEvent:\n        \"\"\"Emit IndicatorsWarmingEvent when indicator warmup begins.\n\n        Args:\n            strategy_id: Strategy identifier.\n            indicator_count: Number of indicators to warm.\n            lookback_days: Historical data lookback in days.\n            ts_event: Event timestamp (nanoseconds). If None, uses current time.\n\n        Returns:\n            The emitted event.\n        \"\"\"\n        event = IndicatorsWarmingEvent(\n            trader_id=self._trader_id,\n            strategy_id=strategy_id,\n            ts_event=ts_event or _now_ns(),\n            indicator_count=indicator_count,\n            lookback_days=lookback_days,\n        )\n        self._emit(event)\n        return event\n\n    def emit_warmup_complete(\n        self,\n        strategy_id: str,\n        warmup_duration_ms: float,\n        bars_processed: int,\n        ts_event: int | None = None,\n    ) -> IndicatorsReadyEvent:\n        \"\"\"Emit IndicatorsReadyEvent when indicator warmup completes.\n\n        Args:\n            strategy_id: Strategy identifier.\n            warmup_duration_ms: Warmup duration in milliseconds.\n            bars_processed: Number of bars processed during warmup.\n            ts_event: Event timestamp (nanoseconds). If None, uses current time.\n\n        Returns:\n            The emitted event.\n        \"\"\"\n        event = IndicatorsReadyEvent(\n            trader_id=self._trader_id,\n            strategy_id=strategy_id,\n            ts_event=ts_event or _now_ns(),\n            warmup_duration_ms=warmup_duration_ms,\n            bars_processed=bars_processed,\n        )\n        self._emit(event)\n        return event\n\n    def emit_reconciliation_complete(\n        self,\n        positions_recovered: int,\n        discrepancies_resolved: int,\n        total_duration_ms: float,\n        strategies_ready: int,\n        ts_event: int | None = None,\n    ) -> RecoveryCompletedEvent:\n        \"\"\"Emit RecoveryCompletedEvent when recovery completes successfully.\n\n        Args:\n            positions_recovered: Number of positions recovered.\n            discrepancies_resolved: Number of discrepancies resolved.\n            total_duration_ms: Total recovery duration in milliseconds.\n            strategies_ready: Number of strategies ready for trading.\n            ts_event: Event timestamp (nanoseconds). If None, uses current time.\n\n        Returns:\n            The emitted event.\n        \"\"\"\n        event = RecoveryCompletedEvent(\n            trader_id=self._trader_id,\n            ts_event=ts_event or _now_ns(),\n            positions_recovered=positions_recovered,\n            discrepancies_resolved=discrepancies_resolved,\n            total_duration_ms=total_duration_ms,\n            strategies_ready=strategies_ready,\n        )\n        self._emit(event)\n        return event\n\n    def emit_recovery_failed(\n        self,\n        error_code: str,\n        error_message: str,\n        positions_recovered: int,\n        recoverable: bool,\n        ts_event: int | None = None,\n    ) -> RecoveryFailedEvent:\n        \"\"\"Emit RecoveryFailedEvent when recovery fails.\n\n        Args:\n            error_code: Error code for categorization.\n            error_message: Human-readable error message.\n            positions_recovered: Positions recovered before failure.\n            recoverable: Whether recovery can be retried.\n            ts_event: Event timestamp (nanoseconds). If None, uses current time.\n\n        Returns:\n            The emitted event.\n        \"\"\"\n        event = RecoveryFailedEvent(\n            trader_id=self._trader_id,\n            ts_event=ts_event or _now_ns(),\n            error_code=error_code,\n            error_message=error_message,\n            positions_recovered=positions_recovered,\n            recoverable=recoverable,\n        )\n        self._emit(event)\n        return event\n\n    def emit_recovery_timeout(\n        self,\n        timeout_secs: float,\n        elapsed_secs: float,\n        positions_recovered: int,\n        ts_event: int | None = None,\n    ) -> RecoveryTimeoutEvent:\n        \"\"\"Emit RecoveryTimeoutEvent when recovery exceeds max time.\n\n        Args:\n            timeout_secs: Configured timeout in seconds.\n            elapsed_secs: Actual elapsed time in seconds.\n            positions_recovered: Positions recovered before timeout.\n            ts_event: Event timestamp (nanoseconds). If None, uses current time.\n\n        Returns:\n            The emitted event.\n        \"\"\"\n        event = RecoveryTimeoutEvent(\n            trader_id=self._trader_id,\n            ts_event=ts_event or _now_ns(),\n            timeout_secs=timeout_secs,\n            elapsed_secs=elapsed_secs,\n            positions_recovered=positions_recovered,\n        )\n        self._emit(event)\n        return event\nEOF",
      "description": "Create RecoveryEventEmitter implementation"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:53:58.724594",
      "todo_count": 6
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:54:05.810556",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && python -m pytest tests/integration/recovery/test_strategy_recovery.py -v 2>&1",
      "description": "Run integration tests for strategy recovery"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:54:06.179611",
      "todo_count": 6
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:54:14.205741",
      "command": "cat > /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_indicator_warmup.py << 'EOF'\n\"\"\"Unit tests for indicator warmup (FR-002 - T021).\n\nTests:\n- _request_warmup_data() requests historical bars\n- on_historical_data() processes bars\n- _on_warmup_data_received() callback processes bars\n- on_warmup_complete() callback fires\n- Warmup state tracking (bars_processed, duration)\n\"\"\"\n\nfrom datetime import datetime, timedelta, timezone\nfrom unittest.mock import MagicMock, call, patch\n\nimport pytest\n\nfrom strategies.common.recovery.config import RecoveryConfig\nfrom strategies.common.recovery.models import RecoveryState, RecoveryStatus\n\n\n@pytest.mark.recovery\nclass TestRequestWarmupData:\n    \"\"\"Tests for _request_warmup_data method.\"\"\"\n\n    def test_request_warmup_calculates_correct_start_time(\n        self, mock_clock, recovery_config\n    ):\n        \"\"\"Test that warmup start time is calculated correctly.\"\"\"\n        # Fixed time: 2024-01-02 00:00:00 UTC\n        mock_clock.utc_now.return_value = datetime(\n            2024, 1, 2, 0, 0, 0, tzinfo=timezone.utc\n        )\n        lookback_days = recovery_config.warmup_lookback_days  # 2 days\n\n        # Simulate _request_warmup_data calculation\n        start_time = mock_clock.utc_now() - timedelta(days=lookback_days)\n\n        # Expected: 2023-12-31 00:00:00 UTC\n        expected = datetime(2023, 12, 31, 0, 0, 0, tzinfo=timezone.utc)\n        assert start_time == expected\n\n    def test_request_warmup_uses_config_lookback_days(self):\n        \"\"\"Test that warmup uses configured lookback days.\"\"\"\n        config = RecoveryConfig(\n            trader_id=\"TESTER-001\",\n            warmup_lookback_days=5,\n        )\n\n        assert config.warmup_lookback_days == 5\n\n    def test_request_warmup_lookback_days_default(self):\n        \"\"\"Test default warmup lookback days is 2.\"\"\"\n        config = RecoveryConfig(trader_id=\"TESTER-001\")\n\n        assert config.warmup_lookback_days == 2\n\n    def test_request_warmup_lookback_days_validation(self):\n        \"\"\"Test warmup lookback days validation (1-30).\"\"\"\n        # Valid range\n        config_min = RecoveryConfig(trader_id=\"T1\", warmup_lookback_days=1)\n        config_max = RecoveryConfig(trader_id=\"T1\", warmup_lookback_days=30)\n        assert config_min.warmup_lookback_days == 1\n        assert config_max.warmup_lookback_days == 30\n\n        # Invalid: below minimum\n        with pytest.raises(ValueError):\n            RecoveryConfig(trader_id=\"T1\", warmup_lookback_days=0)\n\n        # Invalid: above maximum\n        with pytest.raises(ValueError):\n            RecoveryConfig(trader_id=\"T1\", warmup_lookback_days=31)\n\n\n@pytest.mark.recovery\nclass TestOnHistoricalData:\n    \"\"\"Tests for on_historical_data callback.\"\"\"\n\n    def test_on_historical_data_is_callable(self):\n        \"\"\"Test that on_historical_data is a valid hook method.\"\"\"\n        from strategies.common.recovery.recoverable_strategy import (\n            RecoverableStrategy,\n        )\n\n        assert hasattr(RecoverableStrategy, \"on_historical_data\")\n        assert callable(getattr(RecoverableStrategy, \"on_historical_data\"))\n\n    def test_on_historical_data_processes_single_bar(self):\n        \"\"\"Test processing a single historical bar.\"\"\"\n        bars_processed = []\n\n        def on_historical_data(bar):\n            bars_processed.append(bar)\n\n        mock_bar = MagicMock()\n        mock_bar.ts_event = 1704067200000000000\n\n        on_historical_data(mock_bar)\n\n        assert len(bars_processed) == 1\n        assert bars_processed[0].ts_event == 1704067200000000000\n\n    def test_on_historical_data_processes_multiple_bars(self):\n        \"\"\"Test processing multiple historical bars in order.\"\"\"\n        bars_processed = []\n\n        def on_historical_data(bar):\n            bars_processed.append(bar)\n\n        # Create bars with different timestamps\n        for i in range(5):\n            mock_bar = MagicMock()\n            mock_bar.ts_event = 1704067200000000000 + (i * 60_000_000_000)  # 1 min apart\n            on_historical_data(mock_bar)\n\n        assert len(bars_processed) == 5\n\n    def test_on_historical_data_can_feed_indicators(self):\n        \"\"\"Test that on_historical_data can feed bars to indicators.\"\"\"\n        # Simulate indicator being fed bars\n        mock_indicator = MagicMock()\n        bars_fed = []\n\n        def on_historical_data(bar):\n            mock_indicator.handle_bar(bar)\n            bars_fed.append(bar)\n\n        mock_bar = MagicMock()\n        on_historical_data(mock_bar)\n\n        mock_indicator.handle_bar.assert_called_once_with(mock_bar)\n        assert len(bars_fed) == 1\n\n\n@pytest.mark.recovery\nclass TestWarmupDataReceived:\n    \"\"\"Tests for _on_warmup_data_received callback.\"\"\"\n\n    def test_warmup_data_received_empty_bars(self, mock_logger):\n        \"\"\"Test handling empty bars list from warmup request.\"\"\"\n        warmup_complete = False\n\n        def on_warmup_data_received(bars):\n            nonlocal warmup_complete\n            if not bars:\n                mock_logger.warning(\"No warmup bars received\")\n                warmup_complete = True\n\n        on_warmup_data_received([])\n\n        mock_logger.warning.assert_called_with(\"No warmup bars received\")\n        assert warmup_complete is True\n\n    def test_warmup_data_received_sorts_bars_by_timestamp(self):\n        \"\"\"Test that bars are sorted by timestamp (oldest first).\"\"\"\n        # Create bars out of order\n        bar1 = MagicMock()\n        bar1.ts_event = 1704067260000000000  # Later\n        bar2 = MagicMock()\n        bar2.ts_event = 1704067200000000000  # Earlier\n        bar3 = MagicMock()\n        bar3.ts_event = 1704067230000000000  # Middle\n\n        bars = [bar1, bar2, bar3]\n\n        # Simulate sorting logic from _on_warmup_data_received\n        sorted_bars = sorted(bars, key=lambda b: b.ts_event)\n\n        assert sorted_bars[0].ts_event == 1704067200000000000  # Earliest first\n        assert sorted_bars[1].ts_event == 1704067230000000000\n        assert sorted_bars[2].ts_event == 1704067260000000000  # Latest last\n\n    def test_warmup_data_received_counts_processed_bars(self):\n        \"\"\"Test that warmup_bars_processed is incremented correctly.\"\"\"\n        warmup_bars_processed = 0\n\n        def on_warmup_data_received(bars):\n            nonlocal warmup_bars_processed\n            sorted_bars = sorted(bars, key=lambda b: b.ts_event)\n            for bar in sorted_bars:\n                # Process bar\n                warmup_bars_processed += 1\n\n        # Create 10 mock bars\n        bars = [MagicMock(ts_event=1704067200000000000 + i * 60_000_000_000) for i in range(10)]\n        on_warmup_data_received(bars)\n\n        assert warmup_bars_processed == 10\n\n    def test_warmup_data_received_logs_bar_count(self, mock_logger):\n        \"\"\"Test that received bar count is logged.\"\"\"\n        def on_warmup_data_received(bars):\n            if bars:\n                mock_logger.info(f\"Received {len(bars)} warmup bars\")\n\n        bars = [MagicMock() for _ in range(100)]\n        on_warmup_data_received(bars)\n\n        mock_logger.info.assert_called_with(\"Received 100 warmup bars\")\n\n\n@pytest.mark.recovery\nclass TestCompleteWarmup:\n    \"\"\"Tests for _complete_warmup and on_warmup_complete.\"\"\"\n\n    def test_complete_warmup_sets_flag_true(self):\n        \"\"\"Test that _complete_warmup sets warmup_complete to True.\"\"\"\n        warmup_complete = False\n\n        def complete_warmup():\n            nonlocal warmup_complete\n            warmup_complete = True\n\n        complete_warmup()\n\n        assert warmup_complete is True\n\n    def test_complete_warmup_calculates_duration(self, mock_clock):\n        \"\"\"Test that warmup duration is calculated correctly.\"\"\"\n        warmup_start_ns = 1704153600000000000  # Start time\n        # Simulate 500ms later\n        mock_clock.timestamp_ns.return_value = 1704153600500000000\n\n        # Calculate duration\n        warmup_duration_ns = mock_clock.timestamp_ns() - warmup_start_ns\n        warmup_duration_ms = warmup_duration_ns / 1_000_000\n\n        assert warmup_duration_ms == 500.0\n\n    def test_complete_warmup_updates_recovery_state(self, mock_clock):\n        \"\"\"Test that _complete_warmup updates recovery state correctly.\"\"\"\n        state = RecoveryState(\n            status=RecoveryStatus.IN_PROGRESS,\n            positions_recovered=2,\n            indicators_warmed=False,\n            orders_reconciled=False,\n            ts_started=1704153600000000000,\n        )\n\n        # Simulate _complete_warmup state update\n        new_state = RecoveryState(\n            status=RecoveryStatus.COMPLETED,\n            positions_recovered=state.positions_recovered,\n            indicators_warmed=True,\n            orders_reconciled=True,\n            ts_started=state.ts_started,\n            ts_completed=mock_clock.timestamp_ns(),\n        )\n\n        assert new_state.status == RecoveryStatus.COMPLETED\n        assert new_state.indicators_warmed is True\n        assert new_state.orders_reconciled is True\n        assert new_state.ts_completed is not None\n\n    def test_on_warmup_complete_hook_is_called(self):\n        \"\"\"Test that on_warmup_complete hook is called after warmup.\"\"\"\n        on_warmup_complete_called = False\n\n        def on_warmup_complete():\n            nonlocal on_warmup_complete_called\n            on_warmup_complete_called = True\n\n        def complete_warmup():\n            # Complete warmup logic...\n            on_warmup_complete()\n\n        complete_warmup()\n\n        assert on_warmup_complete_called is True\n\n    def test_on_warmup_complete_is_overridable(self):\n        \"\"\"Test that on_warmup_complete can be overridden in subclasses.\"\"\"\n        from strategies.common.recovery.recoverable_strategy import (\n            RecoverableStrategy,\n        )\n\n        # Verify the method exists and is meant to be overridden\n        assert hasattr(RecoverableStrategy, \"on_warmup_complete\")\n\n        # Base implementation does nothing (pass)\n        # Subclasses can override to add custom behavior\n\n    def test_complete_warmup_logs_summary(self, mock_logger):\n        \"\"\"Test that warmup completion is logged with summary.\"\"\"\n        warmup_bars_processed = 150\n        warmup_duration_ms = 250.5\n\n        def complete_warmup():\n            mock_logger.info(\n                f\"Warmup complete: \"\n                f\"bars_processed={warmup_bars_processed}, \"\n                f\"duration_ms={warmup_duration_ms:.1f}\"\n            )\n\n        complete_warmup()\n\n        mock_logger.info.assert_called_with(\n            \"Warmup complete: bars_processed=150, duration_ms=250.5\"\n        )\n\n\n@pytest.mark.recovery\nclass TestWarmupStateTracking:\n    \"\"\"Tests for warmup state tracking variables.\"\"\"\n\n    def test_warmup_bars_processed_starts_at_zero(self):\n        \"\"\"Test initial warmup_bars_processed is zero.\"\"\"\n        warmup_bars_processed = 0\n        assert warmup_bars_processed == 0\n\n    def test_warmup_start_ns_is_set_on_start(self, mock_clock):\n        \"\"\"Test that warmup_start_ns is set when warmup begins.\"\"\"\n        warmup_start_ns = None\n\n        def start_warmup():\n            nonlocal warmup_start_ns\n            warmup_start_ns = mock_clock.timestamp_ns()\n\n        start_warmup()\n\n        assert warmup_start_ns == 1704153600000000000\n\n    def test_warmup_complete_flag_transitions(self):\n        \"\"\"Test warmup_complete flag transitions from False to True.\"\"\"\n        warmup_complete = False\n        assert warmup_complete is False\n\n        # After warmup\n        warmup_complete = True\n        assert warmup_complete is True\n\n    def test_recovery_state_duration_calculation(self):\n        \"\"\"Test RecoveryState.recovery_duration_ms property.\"\"\"\n        state = RecoveryState(\n            status=RecoveryStatus.COMPLETED,\n            ts_started=1704153600000000000,  # 0ms\n            ts_completed=1704153600500000000,  # 500ms later\n        )\n\n        assert state.recovery_duration_ms == 500.0\n\n    def test_recovery_state_duration_none_if_incomplete(self):\n        \"\"\"Test recovery_duration_ms is None if not completed.\"\"\"\n        state = RecoveryState(\n            status=RecoveryStatus.IN_PROGRESS,\n            ts_started=1704153600000000000,\n            ts_completed=None,\n        )\n\n        assert state.recovery_duration_ms is None\n\n\n@pytest.mark.recovery\nclass TestWarmupIntegration:\n    \"\"\"Integration tests for the full warmup flow.\"\"\"\n\n    def test_full_warmup_flow(self, mock_clock, mock_logger):\n        \"\"\"Test the complete warmup flow from request to completion.\"\"\"\n        # Initial state\n        warmup_complete = False\n        warmup_bars_processed = 0\n        warmup_start_ns = mock_clock.timestamp_ns()\n        recovery_state = RecoveryState(\n            status=RecoveryStatus.IN_PROGRESS,\n            ts_started=warmup_start_ns,\n        )\n\n        # Step 1: Request warmup data (simulated)\n        mock_logger.info(\"Requesting warmup data\")\n\n        # Step 2: Receive bars (simulated callback)\n        bars = [MagicMock(ts_event=1704067200000000000 + i * 60_000_000_000) for i in range(50)]\n        sorted_bars = sorted(bars, key=lambda b: b.ts_event)\n\n        # Step 3: Process bars\n        for bar in sorted_bars:\n            warmup_bars_processed += 1\n\n        # Step 4: Complete warmup\n        warmup_complete = True\n        mock_clock.timestamp_ns.return_value = 1704153600250000000  # 250ms later\n\n        recovery_state = RecoveryState(\n            status=RecoveryStatus.COMPLETED,\n            positions_recovered=recovery_state.positions_recovered,\n            indicators_warmed=True,\n            orders_reconciled=True,\n            ts_started=warmup_start_ns,\n            ts_completed=mock_clock.timestamp_ns(),\n        )\n\n        # Verify final state\n        assert warmup_complete is True\n        assert warmup_bars_processed == 50\n        assert recovery_state.status == RecoveryStatus.COMPLETED\n        assert recovery_state.indicators_warmed is True\n        assert recovery_state.recovery_duration_ms == 250.0\nEOF\necho \"Created test_indicator_warmup.py\"",
      "description": "Create T021 test file for indicator warmup"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:54:23.191586",
      "todo_count": 7
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:54:41.459697",
      "command": "cat > /media/sam/1TB/nautilus_dev/strategies/common/recovery/state_manager.py << 'EOF'\n\"\"\"Recovery State Manager (Spec 017).\n\nThis module implements the RecoveryStateManager for tracking and persisting\nrecovery state during TradingNode restarts.\n\nImplementation Note:\n    MVP uses JSON file persistence. Future versions may integrate with\n    Redis or other distributed state stores.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nimport time\nfrom pathlib import Path\nfrom typing import Any\n\nfrom strategies.common.recovery.models import (\n    RecoveryState,\n    RecoveryStatus,\n)\n\n\n# Module logger\n_log = logging.getLogger(__name__)\n\n\ndef _now_ns() -> int:\n    \"\"\"Get current time in nanoseconds.\"\"\"\n    return int(time.time() * 1_000_000_000)\n\n\nclass RecoveryStateManager:\n    \"\"\"Manager for recovery state tracking and persistence.\n\n    Tracks recovery progress and persists state to JSON file for\n    crash recovery. Provides methods to update, save, and load state.\n\n    Attributes:\n        trader_id: Trader identifier for state isolation.\n        state_dir: Directory for state file persistence.\n        state: Current recovery state.\n\n    Example:\n        >>> manager = RecoveryStateManager(\n        ...     trader_id=\"TRADER-001\",\n        ...     state_dir=Path(\"/var/nautilus/state\"),\n        ... )\n        >>> manager.start_recovery()\n        >>> manager.increment_positions_recovered()\n        >>> manager.set_indicators_warmed()\n        >>> manager.complete_recovery()\n        >>> manager.save_state()\n    \"\"\"\n\n    def __init__(\n        self,\n        trader_id: str,\n        state_dir: Path | str | None = None,\n        logger: logging.Logger | None = None,\n    ) -> None:\n        \"\"\"Initialize the RecoveryStateManager.\n\n        Args:\n            trader_id: Trader identifier for state file naming.\n            state_dir: Directory for state file persistence.\n                      If None, state is held in memory only.\n            logger: Optional custom logger. If None, uses module logger.\n        \"\"\"\n        self._trader_id = trader_id\n        self._state_dir = Path(state_dir) if state_dir else None\n        self._log = logger or _log\n        self._state = RecoveryState()\n\n        # Ensure state directory exists\n        if self._state_dir:\n            self._state_dir.mkdir(parents=True, exist_ok=True)\n\n    @property\n    def trader_id(self) -> str:\n        \"\"\"Trader identifier for state isolation.\"\"\"\n        return self._trader_id\n\n    @property\n    def state(self) -> RecoveryState:\n        \"\"\"Current recovery state (read-only copy).\"\"\"\n        return self._state.model_copy()\n\n    @property\n    def state_file_path(self) -> Path | None:\n        \"\"\"Path to the state file, if state_dir is configured.\"\"\"\n        if self._state_dir:\n            return self._state_dir / f\"recovery_state_{self._trader_id}.json\"\n        return None\n\n    def get_state(self) -> RecoveryState:\n        \"\"\"Get current recovery state.\n\n        Returns:\n            Copy of the current recovery state.\n        \"\"\"\n        return self._state.model_copy()\n\n    def update_state(self, **kwargs: Any) -> RecoveryState:\n        \"\"\"Update recovery state with provided values.\n\n        Creates a new state instance with updated values.\n        Use specific methods (start_recovery, complete_recovery, etc.)\n        for common state transitions.\n\n        Args:\n            **kwargs: Fields to update on the state.\n\n        Returns:\n            The updated recovery state.\n\n        Example:\n            >>> manager.update_state(\n            ...     positions_recovered=5,\n            ...     indicators_warmed=True,\n            ... )\n        \"\"\"\n        current_dict = self._state.model_dump()\n        current_dict.update(kwargs)\n        self._state = RecoveryState(**current_dict)\n        self._log.debug(\"Recovery state updated: %s\", kwargs)\n        return self._state.model_copy()\n\n    def start_recovery(self) -> RecoveryState:\n        \"\"\"Mark recovery as started.\n\n        Sets status to IN_PROGRESS and records start timestamp.\n\n        Returns:\n            The updated recovery state.\n        \"\"\"\n        self._state = RecoveryState(\n            status=RecoveryStatus.IN_PROGRESS,\n            ts_started=_now_ns(),\n            positions_recovered=0,\n            indicators_warmed=False,\n            orders_reconciled=False,\n            ts_completed=None,\n            error_message=None,\n        )\n        self._log.info(\"Recovery started for trader_id=%s\", self._trader_id)\n        return self._state.model_copy()\n\n    def increment_positions_recovered(self, count: int = 1) -> RecoveryState:\n        \"\"\"Increment the count of recovered positions.\n\n        Args:\n            count: Number to add to positions_recovered.\n\n        Returns:\n            The updated recovery state.\n        \"\"\"\n        return self.update_state(\n            positions_recovered=self._state.positions_recovered + count\n        )\n\n    def set_indicators_warmed(self, warmed: bool = True) -> RecoveryState:\n        \"\"\"Set indicators warmed status.\n\n        Args:\n            warmed: Whether indicators are warmed.\n\n        Returns:\n            The updated recovery state.\n        \"\"\"\n        return self.update_state(indicators_warmed=warmed)\n\n    def set_orders_reconciled(self, reconciled: bool = True) -> RecoveryState:\n        \"\"\"Set orders reconciled status.\n\n        Args:\n            reconciled: Whether orders are reconciled.\n\n        Returns:\n            The updated recovery state.\n        \"\"\"\n        return self.update_state(orders_reconciled=reconciled)\n\n    def complete_recovery(self) -> RecoveryState:\n        \"\"\"Mark recovery as completed successfully.\n\n        Sets status to COMPLETED and records completion timestamp.\n\n        Returns:\n            The updated recovery state.\n        \"\"\"\n        self._state = RecoveryState(\n            status=RecoveryStatus.COMPLETED,\n            ts_started=self._state.ts_started,\n            ts_completed=_now_ns(),\n            positions_recovered=self._state.positions_recovered,\n            indicators_warmed=self._state.indicators_warmed,\n            orders_reconciled=self._state.orders_reconciled,\n            error_message=None,\n        )\n        self._log.info(\n            \"Recovery completed for trader_id=%s: positions=%d duration_ms=%s\",\n            self._trader_id,\n            self._state.positions_recovered,\n            self._state.recovery_duration_ms,\n        )\n        return self._state.model_copy()\n\n    def fail_recovery(self, error_message: str) -> RecoveryState:\n        \"\"\"Mark recovery as failed.\n\n        Sets status to FAILED and records error message.\n\n        Args:\n            error_message: Human-readable error message.\n\n        Returns:\n            The updated recovery state.\n        \"\"\"\n        self._state = RecoveryState(\n            status=RecoveryStatus.FAILED,\n            ts_started=self._state.ts_started,\n            ts_completed=_now_ns(),\n            positions_recovered=self._state.positions_recovered,\n            indicators_warmed=self._state.indicators_warmed,\n            orders_reconciled=self._state.orders_reconciled,\n            error_message=error_message,\n        )\n        self._log.error(\n            \"Recovery failed for trader_id=%s: %s\",\n            self._trader_id,\n            error_message,\n        )\n        return self._state.model_copy()\n\n    def timeout_recovery(self) -> RecoveryState:\n        \"\"\"Mark recovery as timed out.\n\n        Sets status to TIMEOUT and records completion timestamp.\n\n        Returns:\n            The updated recovery state.\n        \"\"\"\n        self._state = RecoveryState(\n            status=RecoveryStatus.TIMEOUT,\n            ts_started=self._state.ts_started,\n            ts_completed=_now_ns(),\n            positions_recovered=self._state.positions_recovered,\n            indicators_warmed=self._state.indicators_warmed,\n            orders_reconciled=self._state.orders_reconciled,\n            error_message=\"Recovery exceeded max_recovery_time_secs\",\n        )\n        self._log.warning(\n            \"Recovery timed out for trader_id=%s: positions=%d\",\n            self._trader_id,\n            self._state.positions_recovered,\n        )\n        return self._state.model_copy()\n\n    def reset_state(self) -> RecoveryState:\n        \"\"\"Reset state to initial PENDING state.\n\n        Useful for retry scenarios or testing.\n\n        Returns:\n            The reset recovery state.\n        \"\"\"\n        self._state = RecoveryState()\n        self._log.debug(\"Recovery state reset for trader_id=%s\", self._trader_id)\n        return self._state.model_copy()\n\n    def save_state(self) -> bool:\n        \"\"\"Persist current state to JSON file.\n\n        Returns:\n            True if save succeeded, False if state_dir not configured.\n\n        Raises:\n            IOError: If file write fails.\n        \"\"\"\n        if not self.state_file_path:\n            self._log.warning(\n                \"Cannot save state: state_dir not configured for trader_id=%s\",\n                self._trader_id,\n            )\n            return False\n\n        state_dict = self._state.model_dump(mode=\"json\")\n        state_dict[\"trader_id\"] = self._trader_id\n        state_dict[\"ts_saved\"] = _now_ns()\n\n        try:\n            with open(self.state_file_path, \"w\") as f:\n                json.dump(state_dict, f, indent=2)\n            self._log.info(\n                \"Recovery state saved to %s\",\n                self.state_file_path,\n            )\n            return True\n        except Exception as e:\n            self._log.error(\n                \"Failed to save recovery state to %s: %s\",\n                self.state_file_path,\n                e,\n            )\n            raise\n\n    def load_state(self) -> RecoveryState | None:\n        \"\"\"Load state from JSON file.\n\n        Returns:\n            Loaded recovery state, or None if file doesn't exist.\n\n        Raises:\n            IOError: If file read fails.\n            ValidationError: If JSON doesn't match RecoveryState schema.\n        \"\"\"\n        if not self.state_file_path:\n            self._log.warning(\n                \"Cannot load state: state_dir not configured for trader_id=%s\",\n                self._trader_id,\n            )\n            return None\n\n        if not self.state_file_path.exists():\n            self._log.info(\n                \"No existing state file found at %s\",\n                self.state_file_path,\n            )\n            return None\n\n        try:\n            with open(self.state_file_path) as f:\n                state_dict = json.load(f)\n\n            # Remove non-model fields\n            state_dict.pop(\"trader_id\", None)\n            state_dict.pop(\"ts_saved\", None)\n\n            self._state = RecoveryState(**state_dict)\n            self._log.info(\n                \"Recovery state loaded from %s: status=%s positions=%d\",\n                self.state_file_path,\n                self._state.status.value,\n                self._state.positions_recovered,\n            )\n            return self._state.model_copy()\n        except Exception as e:\n            self._log.error(\n                \"Failed to load recovery state from %s: %s\",\n                self.state_file_path,\n                e,\n            )\n            raise\n\n    def delete_state_file(self) -> bool:\n        \"\"\"Delete the state file if it exists.\n\n        Useful for cleanup after successful recovery.\n\n        Returns:\n            True if file was deleted, False if not applicable.\n        \"\"\"\n        if not self.state_file_path:\n            return False\n\n        if self.state_file_path.exists():\n            self.state_file_path.unlink()\n            self._log.info(\n                \"Recovery state file deleted: %s\",\n                self.state_file_path,\n            )\n            return True\n\n        return False\nEOF",
      "description": "Create RecoveryStateManager implementation"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:54:48.295655",
      "todo_count": 6
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:01.472492",
      "command": "cat > /media/sam/1TB/nautilus_dev/strategies/common/recovery/__init__.py << 'EOF'\n\"\"\"Position Recovery Module (Spec 017).\n\nThis module provides position recovery capabilities for NautilusTrader\nstrategies, enabling seamless state restoration after TradingNode restarts.\n\nKey Components:\n- RecoveryConfig: Configuration for recovery behavior\n- RecoverableStrategy: Base class with recovery support\n- PositionRecoveryProvider: Position loading and reconciliation\n- RecoveryEventEmitter: Event emission for monitoring\n- RecoveryStateManager: State tracking and persistence\n\"\"\"\n\nfrom strategies.common.recovery.config import RecoveryConfig\nfrom strategies.common.recovery.event_emitter import RecoveryEventEmitter\nfrom strategies.common.recovery.events import (\n    IndicatorsReadyEvent,\n    IndicatorsWarmingEvent,\n    PositionDiscrepancyEvent,\n    PositionLoadedEvent,\n    PositionReconciledEvent,\n    RecoveryCompletedEvent,\n    RecoveryEventType,\n    RecoveryFailedEvent,\n    RecoveryStartedEvent,\n    RecoveryTimeoutEvent,\n)\nfrom strategies.common.recovery.models import (\n    IndicatorState,\n    PositionSnapshot,\n    RecoveryState,\n    RecoveryStatus,\n    StrategySnapshot,\n)\nfrom strategies.common.recovery.provider import PositionRecoveryProvider\nfrom strategies.common.recovery.recoverable_strategy import (\n    RecoverableStrategy,\n    RecoverableStrategyConfig,\n)\nfrom strategies.common.recovery.state_manager import RecoveryStateManager\n\n__all__ = [\n    # Config\n    \"RecoveryConfig\",\n    # Models\n    \"RecoveryStatus\",\n    \"RecoveryState\",\n    \"PositionSnapshot\",\n    \"IndicatorState\",\n    \"StrategySnapshot\",\n    # Events\n    \"RecoveryEventType\",\n    \"RecoveryStartedEvent\",\n    \"PositionLoadedEvent\",\n    \"PositionReconciledEvent\",\n    \"PositionDiscrepancyEvent\",\n    \"IndicatorsWarmingEvent\",\n    \"IndicatorsReadyEvent\",\n    \"RecoveryCompletedEvent\",\n    \"RecoveryFailedEvent\",\n    \"RecoveryTimeoutEvent\",\n    # Provider\n    \"PositionRecoveryProvider\",\n    # Event Emitter\n    \"RecoveryEventEmitter\",\n    # State Manager\n    \"RecoveryStateManager\",\n    # Strategy\n    \"RecoverableStrategy\",\n    \"RecoverableStrategyConfig\",\n]\nEOF",
      "description": "Update __init__.py with new exports"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:55:08.486724",
      "todo_count": 6
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:10.718662",
      "command": "cat > /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_exit_order_recreation.py << 'EOF'\n\"\"\"Unit tests for exit order recreation (FR-002 - T022).\n\nTests:\n- _setup_exit_orders() checks for existing stops\n- _is_stop_order() identifies stop order types\n- Stop-loss detection for recovered positions\n- Warning logged when no stop-loss found\n\"\"\"\n\nfrom unittest.mock import MagicMock, call, patch\n\nimport pytest\n\nfrom nautilus_trader.model.enums import OrderType\n\n\n@pytest.mark.recovery\nclass TestSetupExitOrders:\n    \"\"\"Tests for _setup_exit_orders method.\"\"\"\n\n    def test_setup_exit_orders_checks_open_orders(self, mock_cache):\n        \"\"\"Test that _setup_exit_orders checks open orders from cache.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        # Create mock position\n        mock_position = MagicMock()\n        mock_position.instrument_id = InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n\n        # Setup cache to return empty orders\n        mock_cache.orders_open.return_value = []\n\n        # Simulate _setup_exit_orders logic\n        open_orders = mock_cache.orders_open(instrument_id=mock_position.instrument_id)\n\n        mock_cache.orders_open.assert_called_with(\n            instrument_id=InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n        )\n        assert open_orders == []\n\n    def test_setup_exit_orders_finds_existing_stop(self, mock_cache, mock_logger):\n        \"\"\"Test that existing stop-loss is detected.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        # Create mock position\n        mock_position = MagicMock()\n        mock_position.instrument_id = InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n\n        # Create mock stop-loss order\n        mock_stop_order = MagicMock()\n        mock_stop_order.order_type = OrderType.STOP_MARKET\n\n        mock_cache.orders_open.return_value = [mock_stop_order]\n\n        # Simulate _setup_exit_orders logic\n        def is_stop_order(order):\n            return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n        open_orders = mock_cache.orders_open(instrument_id=mock_position.instrument_id)\n        has_stop = any(is_stop_order(order) for order in open_orders)\n\n        if has_stop:\n            mock_logger.info(f\"Stop-loss already exists for {mock_position.instrument_id}\")\n\n        assert has_stop is True\n        mock_logger.info.assert_called()\n\n    def test_setup_exit_orders_logs_warning_when_no_stop(self, mock_cache, mock_logger):\n        \"\"\"Test warning logged when no stop-loss exists.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        # Create mock position\n        mock_position = MagicMock()\n        mock_position.instrument_id = InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n\n        # No stop orders\n        mock_cache.orders_open.return_value = []\n\n        # Simulate _setup_exit_orders logic\n        def is_stop_order(order):\n            return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n        open_orders = mock_cache.orders_open(instrument_id=mock_position.instrument_id)\n        has_stop = any(is_stop_order(order) for order in open_orders)\n\n        if not has_stop:\n            mock_logger.warning(\n                f\"No stop-loss found for recovered position: \"\n                f\"{mock_position.instrument_id}. Override _setup_exit_orders() \"\n                f\"to create one.\"\n            )\n\n        assert has_stop is False\n        mock_logger.warning.assert_called()\n\n    def test_setup_exit_orders_ignores_non_stop_orders(self, mock_cache):\n        \"\"\"Test that non-stop orders are not counted as stops.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        mock_position = MagicMock()\n        mock_position.instrument_id = InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n\n        # Create non-stop orders\n        limit_order = MagicMock()\n        limit_order.order_type = OrderType.LIMIT\n\n        market_order = MagicMock()\n        market_order.order_type = OrderType.MARKET\n\n        mock_cache.orders_open.return_value = [limit_order, market_order]\n\n        # Simulate logic\n        def is_stop_order(order):\n            return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n        open_orders = mock_cache.orders_open(instrument_id=mock_position.instrument_id)\n        has_stop = any(is_stop_order(order) for order in open_orders)\n\n        assert has_stop is False\n\n\n@pytest.mark.recovery\nclass TestIsStopOrder:\n    \"\"\"Tests for _is_stop_order helper method.\"\"\"\n\n    def test_is_stop_order_stop_market_true(self):\n        \"\"\"Test that STOP_MARKET order is identified as stop order.\"\"\"\n        mock_order = MagicMock()\n        mock_order.order_type = OrderType.STOP_MARKET\n\n        def is_stop_order(order):\n            return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n        assert is_stop_order(mock_order) is True\n\n    def test_is_stop_order_stop_limit_true(self):\n        \"\"\"Test that STOP_LIMIT order is identified as stop order.\"\"\"\n        mock_order = MagicMock()\n        mock_order.order_type = OrderType.STOP_LIMIT\n\n        def is_stop_order(order):\n            return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n        assert is_stop_order(mock_order) is True\n\n    def test_is_stop_order_limit_false(self):\n        \"\"\"Test that LIMIT order is not identified as stop order.\"\"\"\n        mock_order = MagicMock()\n        mock_order.order_type = OrderType.LIMIT\n\n        def is_stop_order(order):\n            return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n        assert is_stop_order(mock_order) is False\n\n    def test_is_stop_order_market_false(self):\n        \"\"\"Test that MARKET order is not identified as stop order.\"\"\"\n        mock_order = MagicMock()\n        mock_order.order_type = OrderType.MARKET\n\n        def is_stop_order(order):\n            return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n        assert is_stop_order(mock_order) is False\n\n    def test_is_stop_order_limit_if_touched_false(self):\n        \"\"\"Test that LIMIT_IF_TOUCHED order is not identified as stop order.\"\"\"\n        mock_order = MagicMock()\n        mock_order.order_type = OrderType.LIMIT_IF_TOUCHED\n\n        def is_stop_order(order):\n            return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n        assert is_stop_order(mock_order) is False\n\n\n@pytest.mark.recovery\nclass TestStopOrderDetection:\n    \"\"\"Tests for stop order detection with multiple scenarios.\"\"\"\n\n    def test_detect_stop_among_mixed_orders(self, mock_cache):\n        \"\"\"Test detecting stop order among mixed order types.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        mock_position = MagicMock()\n        mock_position.instrument_id = InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n\n        # Mix of order types\n        limit_order = MagicMock()\n        limit_order.order_type = OrderType.LIMIT\n\n        stop_order = MagicMock()\n        stop_order.order_type = OrderType.STOP_MARKET\n\n        market_order = MagicMock()\n        market_order.order_type = OrderType.MARKET\n\n        mock_cache.orders_open.return_value = [limit_order, stop_order, market_order]\n\n        def is_stop_order(order):\n            return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n        open_orders = mock_cache.orders_open(instrument_id=mock_position.instrument_id)\n        has_stop = any(is_stop_order(order) for order in open_orders)\n\n        assert has_stop is True\n\n    def test_detect_multiple_stop_orders(self, mock_cache):\n        \"\"\"Test detecting when multiple stop orders exist.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        mock_position = MagicMock()\n        mock_position.instrument_id = InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n\n        # Multiple stop orders\n        stop_market = MagicMock()\n        stop_market.order_type = OrderType.STOP_MARKET\n\n        stop_limit = MagicMock()\n        stop_limit.order_type = OrderType.STOP_LIMIT\n\n        mock_cache.orders_open.return_value = [stop_market, stop_limit]\n\n        def is_stop_order(order):\n            return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n        open_orders = mock_cache.orders_open(instrument_id=mock_position.instrument_id)\n        stop_count = sum(1 for order in open_orders if is_stop_order(order))\n\n        assert stop_count == 2\n\n    def test_no_orders_means_no_stop(self, mock_cache):\n        \"\"\"Test that empty orders list means no stop.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        mock_position = MagicMock()\n        mock_position.instrument_id = InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n\n        mock_cache.orders_open.return_value = []\n\n        def is_stop_order(order):\n            return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n        open_orders = mock_cache.orders_open(instrument_id=mock_position.instrument_id)\n        has_stop = any(is_stop_order(order) for order in open_orders)\n\n        assert has_stop is False\n\n\n@pytest.mark.recovery\nclass TestExitOrderRecreationIntegration:\n    \"\"\"Integration tests for exit order recreation flow.\"\"\"\n\n    def test_recovered_position_with_stop_flow(\n        self, mock_cache, mock_logger, mock_btc_position\n    ):\n        \"\"\"Test full flow: recovered position with existing stop.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        # Setup existing stop order\n        stop_order = MagicMock()\n        stop_order.order_type = OrderType.STOP_MARKET\n        mock_cache.orders_open.return_value = [stop_order]\n\n        # Simulate flow\n        def setup_exit_orders(position):\n            def is_stop_order(order):\n                return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n            open_orders = mock_cache.orders_open(instrument_id=position.instrument_id)\n            has_stop = any(is_stop_order(order) for order in open_orders)\n\n            if has_stop:\n                mock_logger.info(f\"Stop-loss already exists for {position.instrument_id}\")\n                return True\n            else:\n                mock_logger.warning(\n                    f\"No stop-loss found for recovered position: {position.instrument_id}\"\n                )\n                return False\n\n        # Set instrument_id properly\n        mock_btc_position.instrument_id = InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n\n        result = setup_exit_orders(mock_btc_position)\n\n        assert result is True\n        mock_logger.info.assert_called()\n\n    def test_recovered_position_without_stop_flow(\n        self, mock_cache, mock_logger, mock_btc_position\n    ):\n        \"\"\"Test full flow: recovered position without existing stop.\"\"\"\n        from nautilus_trader.model.identifiers import InstrumentId\n\n        # No orders exist\n        mock_cache.orders_open.return_value = []\n\n        def setup_exit_orders(position):\n            def is_stop_order(order):\n                return order.order_type in (OrderType.STOP_MARKET, OrderType.STOP_LIMIT)\n\n            open_orders = mock_cache.orders_open(instrument_id=position.instrument_id)\n            has_stop = any(is_stop_order(order) for order in open_orders)\n\n            if has_stop:\n                mock_logger.info(f\"Stop-loss already exists for {position.instrument_id}\")\n                return True\n            else:\n                mock_logger.warning(\n                    f\"No stop-loss found for recovered position: {position.instrument_id}\"\n                )\n                return False\n\n        mock_btc_position.instrument_id = InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\")\n\n        result = setup_exit_orders(mock_btc_position)\n\n        assert result is False\n        mock_logger.warning.assert_called()\n\n    def test_setup_exit_orders_is_overridable(self):\n        \"\"\"Test that _setup_exit_orders can be overridden in subclasses.\"\"\"\n        from strategies.common.recovery.recoverable_strategy import (\n            RecoverableStrategy,\n        )\n\n        # Verify the method exists and can be overridden\n        assert hasattr(RecoverableStrategy, \"_setup_exit_orders\")\n\n        # The base implementation only checks; subclasses should override\n        # to actually create stop orders based on their risk parameters\n\n    def test_handle_recovered_position_calls_setup_exit_orders(\n        self, mock_btc_position\n    ):\n        \"\"\"Test that _handle_recovered_position calls _setup_exit_orders.\"\"\"\n        setup_exit_orders_called = False\n        setup_exit_orders_position = None\n\n        def mock_setup_exit_orders(position):\n            nonlocal setup_exit_orders_called, setup_exit_orders_position\n            setup_exit_orders_called = True\n            setup_exit_orders_position = position\n\n        def handle_recovered_position(position):\n            # Other logic...\n            mock_setup_exit_orders(position)\n            # Call hook...\n\n        handle_recovered_position(mock_btc_position)\n\n        assert setup_exit_orders_called is True\n        assert setup_exit_orders_position == mock_btc_position\n\n\n@pytest.mark.recovery\nclass TestOrderTypeEnums:\n    \"\"\"Tests verifying OrderType enum values used in stop detection.\"\"\"\n\n    def test_stop_market_enum_exists(self):\n        \"\"\"Test that STOP_MARKET enum value exists.\"\"\"\n        assert hasattr(OrderType, \"STOP_MARKET\")\n        assert OrderType.STOP_MARKET is not None\n\n    def test_stop_limit_enum_exists(self):\n        \"\"\"Test that STOP_LIMIT enum value exists.\"\"\"\n        assert hasattr(OrderType, \"STOP_LIMIT\")\n        assert OrderType.STOP_LIMIT is not None\n\n    def test_stop_types_are_different(self):\n        \"\"\"Test that STOP_MARKET and STOP_LIMIT are different values.\"\"\"\n        assert OrderType.STOP_MARKET != OrderType.STOP_LIMIT\n\n    def test_market_is_not_stop(self):\n        \"\"\"Test that MARKET is different from stop types.\"\"\"\n        assert OrderType.MARKET != OrderType.STOP_MARKET\n        assert OrderType.MARKET != OrderType.STOP_LIMIT\n\n    def test_limit_is_not_stop(self):\n        \"\"\"Test that LIMIT is different from stop types.\"\"\"\n        assert OrderType.LIMIT != OrderType.STOP_MARKET\n        assert OrderType.LIMIT != OrderType.STOP_LIMIT\nEOF\necho \"Created test_exit_order_recreation.py\"",
      "description": "Create T022 test file for exit order recreation"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:16.836985",
      "command": "cat > /media/sam/1TB/nautilus_dev/tests/integration/recovery/test_strategy_recovery.py << 'EOF'\n\"\"\"Integration test for strategy recovery (FR-002).\n\nTests that RecoverableStrategy correctly:\n- Starts with recovered positions from cache\n- Requests historical warmup data\n- Calls on_warmup_complete() hook\n- Blocks trading during warmup (is_warming_up)\n- Reports is_ready after warmup completes\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom datetime import datetime, timedelta, timezone\nfrom decimal import Decimal\nfrom unittest.mock import MagicMock, PropertyMock, patch\n\nimport pytest\n\nfrom strategies.common.recovery.config import RecoveryConfig\nfrom strategies.common.recovery.models import RecoveryStatus\nfrom strategies.common.recovery.recoverable_strategy import (\n    RecoverableStrategy,\n    RecoverableStrategyConfig,\n)\n\n\n@pytest.fixture\ndef mock_instrument():\n    \"\"\"Create a mock instrument for testing.\"\"\"\n    instrument = MagicMock()\n    instrument.id.value = \"BTCUSDT-PERP.BINANCE\"\n    return instrument\n\n\n@pytest.fixture\ndef mock_position():\n    \"\"\"Create a mock open position for recovery testing.\"\"\"\n    position = MagicMock()\n    position.instrument_id.value = \"BTCUSDT-PERP.BINANCE\"\n    position.side.value = \"LONG\"\n    position.quantity.as_decimal.return_value = Decimal(\"1.5\")\n    position.avg_px_open = Decimal(\"42000.00\")\n    position.is_open = True\n    return position\n\n\n@pytest.fixture\ndef mock_bar():\n    \"\"\"Create a mock bar for warmup testing.\"\"\"\n    bar = MagicMock()\n    bar.ts_event = 1704067200000000000  # 2024-01-01 00:00:00 UTC\n    bar.close = Decimal(\"42500.00\")\n    bar.open = Decimal(\"42000.00\")\n    bar.high = Decimal(\"42700.00\")\n    bar.low = Decimal(\"41800.00\")\n    bar.volume = Decimal(\"100.0\")\n    return bar\n\n\n@pytest.fixture\ndef strategy_config():\n    \"\"\"Create a RecoverableStrategyConfig for testing.\"\"\"\n    return RecoverableStrategyConfig(\n        instrument_id=\"BTCUSDT-PERP.BINANCE\",\n        bar_type=\"BTCUSDT-PERP.BINANCE-1-MINUTE-LAST-EXTERNAL\",\n        recovery=RecoveryConfig(\n            trader_id=\"TESTER-001\",\n            recovery_enabled=True,\n            warmup_lookback_days=2,\n            startup_delay_secs=10.0,\n            max_recovery_time_secs=30.0,\n        ),\n    )\n\n\n@pytest.fixture\ndef strategy_config_disabled():\n    \"\"\"Create a RecoverableStrategyConfig with recovery disabled.\"\"\"\n    return RecoverableStrategyConfig(\n        instrument_id=\"BTCUSDT-PERP.BINANCE\",\n        bar_type=\"BTCUSDT-PERP.BINANCE-1-MINUTE-LAST-EXTERNAL\",\n        recovery=RecoveryConfig(\n            trader_id=\"TESTER-001\",\n            recovery_enabled=False,\n            warmup_lookback_days=2,\n        ),\n    )\n\n\nclass ConcreteRecoverableStrategy(RecoverableStrategy):\n    \"\"\"Concrete subclass for testing that tracks hook calls.\n\n    Named 'Concrete...' instead of 'Test...' to avoid pytest collection warning.\n    \"\"\"\n\n    def __init__(self, config: RecoverableStrategyConfig) -> None:\n        super().__init__(config)\n        self.position_recovered_calls: list = []\n        self.historical_data_calls: list = []\n        self.warmup_complete_called: bool = False\n\n    def on_position_recovered(self, position) -> None:\n        \"\"\"Track position recovered calls.\"\"\"\n        self.position_recovered_calls.append(position)\n\n    def on_historical_data(self, bar) -> None:\n        \"\"\"Track historical data processing calls.\"\"\"\n        self.historical_data_calls.append(bar)\n\n    def on_warmup_complete(self) -> None:\n        \"\"\"Track warmup complete calls.\"\"\"\n        self.warmup_complete_called = True\n\n\ndef create_strategy_with_mocks(\n    strategy_config,\n    mock_cache,\n    mock_clock,\n):\n    \"\"\"Helper to create strategy with mocked dependencies.\"\"\"\n    strategy = ConcreteRecoverableStrategy(strategy_config)\n\n    # Patch cache and clock properties using object.__setattr__ for Cython objects\n    # We need to patch at the class level for properties\n    return strategy, mock_cache, mock_clock\n\n\n@pytest.mark.integration\n@pytest.mark.recovery\nclass TestStrategyRecovery:\n    \"\"\"Integration tests for RecoverableStrategy (FR-002).\"\"\"\n\n    def test_strategy_starts_with_recovered_position(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        mock_position,\n        strategy_config,\n    ):\n        \"\"\"Test strategy detects and processes recovered position from cache.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = [mock_position]\n        mock_cache.orders_open.return_value = []\n\n        strategy = ConcreteRecoverableStrategy(strategy_config)\n\n        # Patch the properties at class level\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    # Patch request_bars and subscribe_bars\n                    with patch.object(strategy, \"request_bars\"):\n                        with patch.object(strategy, \"subscribe_bars\"):\n                            strategy.on_start()\n\n                    # Verify position was recovered\n                    assert strategy.recovered_positions_count == 1\n                    assert len(strategy.position_recovered_calls) == 1\n                    assert strategy.position_recovered_calls[0] == mock_position\n                    assert strategy.recovery_state.positions_recovered == 1\n\n    def test_strategy_requests_warmup_data(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test strategy requests historical bars for indicator warmup.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = ConcreteRecoverableStrategy(strategy_config)\n        request_bars_mock = MagicMock()\n\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    with patch.object(strategy, \"request_bars\", request_bars_mock):\n                        with patch.object(strategy, \"subscribe_bars\"):\n                            strategy.on_start()\n\n                    # Verify request_bars was called with correct parameters\n                    assert request_bars_mock.called\n                    call_kwargs = request_bars_mock.call_args\n                    assert call_kwargs.kwargs[\"bar_type\"] == strategy.bar_type\n\n                    # Verify start time is approximately warmup_lookback_days ago\n                    expected_start = mock_clock.utc_now.return_value - timedelta(days=2)\n                    assert call_kwargs.kwargs[\"start\"] == expected_start\n\n    def test_warmup_data_processed_and_complete_called(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        mock_bar,\n        strategy_config,\n    ):\n        \"\"\"Test historical data is processed and on_warmup_complete is called.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = ConcreteRecoverableStrategy(strategy_config)\n\n        # Create multiple warmup bars\n        bars = []\n        for i in range(5):\n            bar = MagicMock()\n            bar.ts_event = 1704067200000000000 + (i * 60_000_000_000)  # 1 min apart\n            bars.append(bar)\n\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    # Start strategy (with patched request_bars)\n                    with patch.object(strategy, \"request_bars\"):\n                        with patch.object(strategy, \"subscribe_bars\"):\n                            strategy.on_start()\n\n                    # Simulate warmup data callback\n                    strategy._on_warmup_data_received(bars)\n\n                    # Verify all bars were processed\n                    assert len(strategy.historical_data_calls) == 5\n                    assert strategy._warmup_bars_processed == 5\n\n                    # Verify on_warmup_complete was called\n                    assert strategy.warmup_complete_called\n\n    def test_strategy_is_ready_after_warmup(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test strategy is_ready returns True after warmup completes.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = ConcreteRecoverableStrategy(strategy_config)\n\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    # Start strategy\n                    with patch.object(strategy, \"request_bars\"):\n                        with patch.object(strategy, \"subscribe_bars\"):\n                            strategy.on_start()\n\n                    # Before warmup complete\n                    assert strategy.is_warming_up\n                    assert not strategy.is_ready\n\n                    # Simulate warmup completion\n                    strategy._on_warmup_data_received(\n                        [MagicMock(ts_event=1704067200000000000)]\n                    )\n\n                    # After warmup complete\n                    assert not strategy.is_warming_up\n                    assert strategy.is_ready\n                    assert strategy.recovery_state.status == RecoveryStatus.COMPLETED\n\n    def test_strategy_blocks_trading_during_warmup(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test is_warming_up is True during warmup phase.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = ConcreteRecoverableStrategy(strategy_config)\n\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    # Start strategy\n                    with patch.object(strategy, \"request_bars\"):\n                        with patch.object(strategy, \"subscribe_bars\"):\n                            strategy.on_start()\n\n                    # Strategy should be warming up (blocking trades)\n                    assert strategy.is_warming_up\n                    assert not strategy._warmup_complete\n                    assert strategy.recovery_state.status == RecoveryStatus.IN_PROGRESS\n\n    def test_recovery_state_transitions(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        mock_position,\n        strategy_config,\n    ):\n        \"\"\"Test recovery state transitions through lifecycle.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = [mock_position]\n        mock_cache.orders_open.return_value = []\n\n        strategy = ConcreteRecoverableStrategy(strategy_config)\n\n        # Initial state (before on_start)\n        assert strategy.recovery_state.status == RecoveryStatus.PENDING\n\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    # Start strategy\n                    with patch.object(strategy, \"request_bars\"):\n                        with patch.object(strategy, \"subscribe_bars\"):\n                            strategy.on_start()\n\n                    # After on_start (in progress)\n                    assert strategy.recovery_state.status == RecoveryStatus.IN_PROGRESS\n                    assert strategy.recovery_state.positions_recovered == 1\n                    assert not strategy.recovery_state.indicators_warmed\n\n                    # After warmup complete\n                    strategy._on_warmup_data_received(\n                        [MagicMock(ts_event=1704067200000000000)]\n                    )\n\n                    # Final state\n                    assert strategy.recovery_state.status == RecoveryStatus.COMPLETED\n                    assert strategy.recovery_state.indicators_warmed\n                    assert strategy.recovery_state.orders_reconciled\n                    assert strategy.recovery_state.is_complete\n\n    def test_empty_warmup_data_still_completes(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test warmup completes even with no historical data.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = ConcreteRecoverableStrategy(strategy_config)\n\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    # Start strategy\n                    with patch.object(strategy, \"request_bars\"):\n                        with patch.object(strategy, \"subscribe_bars\"):\n                            strategy.on_start()\n\n                    # Simulate empty warmup data\n                    strategy._on_warmup_data_received([])\n\n                    # Should still complete warmup\n                    assert strategy.warmup_complete_called\n                    assert strategy.is_ready\n                    assert strategy._warmup_bars_processed == 0\n\n    def test_recovery_disabled_skips_position_detection(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        mock_position,\n        strategy_config_disabled,\n    ):\n        \"\"\"Test position detection is skipped when recovery disabled.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = [mock_position]\n\n        strategy = ConcreteRecoverableStrategy(strategy_config_disabled)\n\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    # Start strategy\n                    with patch.object(strategy, \"request_bars\"):\n                        with patch.object(strategy, \"subscribe_bars\"):\n                            strategy.on_start()\n\n                    # Position detection should be skipped\n                    assert strategy.recovered_positions_count == 0\n                    assert len(strategy.position_recovered_calls) == 0\n\n    def test_multiple_positions_recovered(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test multiple positions are recovered correctly.\"\"\"\n        # Setup multiple positions\n        positions = []\n        for i, qty in enumerate([Decimal(\"1.0\"), Decimal(\"2.0\")]):\n            pos = MagicMock()\n            pos.instrument_id = mock_instrument.id\n            pos.instrument_id.value = \"BTCUSDT-PERP.BINANCE\"\n            pos.side.value = \"LONG\"\n            pos.quantity = qty\n            pos.avg_px_open = Decimal(\"42000.00\")\n            pos.is_open = True\n            positions.append(pos)\n\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = positions\n        mock_cache.orders_open.return_value = []\n\n        strategy = ConcreteRecoverableStrategy(strategy_config)\n\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    # Start strategy\n                    with patch.object(strategy, \"request_bars\"):\n                        with patch.object(strategy, \"subscribe_bars\"):\n                            strategy.on_start()\n\n                    # Both positions should be recovered\n                    assert strategy.recovered_positions_count == 2\n                    assert len(strategy.position_recovered_calls) == 2\n                    assert strategy.recovery_state.positions_recovered == 2\n\n    def test_closed_positions_not_recovered(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test closed positions are not processed as recovered.\"\"\"\n        # Setup closed position\n        closed_position = MagicMock()\n        closed_position.instrument_id.value = \"BTCUSDT-PERP.BINANCE\"\n        closed_position.is_open = False\n\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = [closed_position]\n        mock_cache.orders_open.return_value = []\n\n        strategy = ConcreteRecoverableStrategy(strategy_config)\n\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    # Start strategy\n                    with patch.object(strategy, \"request_bars\"):\n                        with patch.object(strategy, \"subscribe_bars\"):\n                            strategy.on_start()\n\n                    # Closed position should not be recovered\n                    assert strategy.recovered_positions_count == 0\n                    assert len(strategy.position_recovered_calls) == 0\n\n    def test_instrument_not_found_stops_strategy(\n        self,\n        mock_cache,\n        mock_clock,\n        strategy_config,\n    ):\n        \"\"\"Test strategy stops if instrument not found in cache.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = None\n\n        strategy = ConcreteRecoverableStrategy(strategy_config)\n        stop_mock = MagicMock()\n\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    with patch.object(strategy, \"stop\", stop_mock):\n                        strategy.on_start()\n\n                    # Strategy should call stop due to missing instrument\n                    assert stop_mock.called\n\n    def test_warmup_bars_sorted_by_timestamp(\n        self,\n        mock_cache,\n        mock_clock,\n        mock_instrument,\n        strategy_config,\n    ):\n        \"\"\"Test warmup bars are processed in chronological order.\"\"\"\n        # Setup\n        mock_cache.instrument.return_value = mock_instrument\n        mock_cache.positions.return_value = []\n\n        strategy = ConcreteRecoverableStrategy(strategy_config)\n\n        # Create bars in reverse order\n        bars = []\n        timestamps = [1704067260000000000, 1704067200000000000, 1704067320000000000]\n        for ts in timestamps:\n            bar = MagicMock()\n            bar.ts_event = ts\n            bars.append(bar)\n\n        with patch.object(type(strategy), \"cache\", new_callable=PropertyMock) as cache_prop:\n            with patch.object(type(strategy), \"clock\", new_callable=PropertyMock) as clock_prop:\n                with patch.object(type(strategy), \"log\", new_callable=PropertyMock) as log_prop:\n                    cache_prop.return_value = mock_cache\n                    clock_prop.return_value = mock_clock\n                    log_prop.return_value = MagicMock()\n\n                    # Start strategy\n                    with patch.object(strategy, \"request_bars\"):\n                        with patch.object(strategy, \"subscribe_bars\"):\n                            strategy.on_start()\n\n                    # Process warmup data\n                    strategy._on_warmup_data_received(bars)\n\n                    # Verify bars were processed in sorted order (oldest first)\n                    processed_timestamps = [\n                        b.ts_event for b in strategy.historical_data_calls\n                    ]\n                    assert processed_timestamps == sorted(timestamps)\nEOF",
      "description": "Update test_strategy_recovery.py with proper property mocking"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:16.903206",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff format strategies/common/recovery/event_emitter.py strategies/common/recovery/state_manager.py strategies/common/recovery/__init__.py",
      "description": "Run ruff format on new files"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:55:19.377726",
      "todo_count": 7
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:24.719435",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff check strategies/common/recovery/event_emitter.py strategies/common/recovery/state_manager.py strategies/common/recovery/__init__.py",
      "description": "Run ruff check on new files"
    },
    {
      "operation": "taskoutput",
      "timestamp": "2025-12-30T19:55:24.874620",
      "task_id": "a590ba9",
      "block": true,
      "timeout": 120000
    },
    {
      "operation": "taskoutput",
      "timestamp": "2025-12-30T19:55:24.879934",
      "task_id": "ab80bed",
      "block": true,
      "timeout": 120000
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:25.565577",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && python -m pytest tests/integration/recovery/test_strategy_recovery.py -v 2>&1",
      "description": "Run updated integration tests"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:26.807704",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && python -m pytest tests/unit/recovery/test_recoverable_strategy.py tests/unit/recovery/test_indicator_warmup.py tests/unit/recovery/test_exit_order_recreation.py -v --tb=short 2>&1",
      "description": "Run unit tests for recovery module"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:55:32.797336",
      "todo_count": 6
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:55:36.538241",
      "todo_count": 6
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:55:38.073311",
      "todo_count": 7
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:44.267714",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff format /media/sam/1TB/nautilus_dev/tests/integration/recovery/test_strategy_recovery.py && ruff check /media/sam/1TB/nautilus_dev/tests/integration/recovery/test_strategy_recovery.py 2>&1",
      "description": "Run ruff format and check on test file"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:44.530703",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && python -c \"\nfrom strategies.common.recovery import (\n    RecoveryEventEmitter,\n    RecoveryStateManager,\n    RecoveryState,\n    RecoveryStatus,\n    RecoveryEventType,\n    RecoveryStartedEvent,\n    PositionLoadedEvent,\n    RecoveryCompletedEvent,\n)\nprint('All imports successful!')\n\n# Quick functional test of RecoveryEventEmitter\nemitter = RecoveryEventEmitter(trader_id='TEST-001')\nevent = emitter.emit_recovery_started(cached_positions_count=3, ts_event=1234567890)\nprint(f'EmittedEvent: {event.event_type}')\nassert event.trader_id == 'TEST-001'\nassert event.cached_positions_count == 3\n\n# Quick functional test of RecoveryStateManager\nimport tempfile\nwith tempfile.TemporaryDirectory() as tmpdir:\n    manager = RecoveryStateManager(trader_id='TEST-001', state_dir=tmpdir)\n    state = manager.start_recovery()\n    assert state.status == RecoveryStatus.IN_PROGRESS\n    \n    manager.increment_positions_recovered(3)\n    manager.set_indicators_warmed()\n    manager.set_orders_reconciled()\n    state = manager.complete_recovery()\n    \n    assert state.status == RecoveryStatus.COMPLETED\n    assert state.positions_recovered == 3\n    assert state.indicators_warmed == True\n    assert state.orders_reconciled == True\n    print(f'StateManager final state: status={state.status.value}, positions={state.positions_recovered}')\n    \n    # Test persistence\n    manager.save_state()\n    manager2 = RecoveryStateManager(trader_id='TEST-001', state_dir=tmpdir)\n    loaded = manager2.load_state()\n    assert loaded.status == RecoveryStatus.COMPLETED\n    print('Persistence test passed!')\n\nprint('All tests passed!')\n\"",
      "description": "Verify imports and basic functionality"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:45.323681",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff format /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_recoverable_strategy.py /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_indicator_warmup.py /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_exit_order_recreation.py && ruff check /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_recoverable_strategy.py /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_indicator_warmup.py /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_exit_order_recreation.py 2>&1",
      "description": "Run ruff format and check on test files"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:52.391378",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff check --fix /media/sam/1TB/nautilus_dev/tests/integration/recovery/test_strategy_recovery.py && ruff format /media/sam/1TB/nautilus_dev/tests/integration/recovery/test_strategy_recovery.py 2>&1",
      "description": "Fix ruff lint issues"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:55:53.071062",
      "todo_count": 6
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:55:53.631258",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff check --fix /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_recoverable_strategy.py /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_indicator_warmup.py /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_exit_order_recreation.py 2>&1",
      "description": "Fix unused imports with ruff"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:56:00.488488",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && python -m pytest tests/integration/recovery/test_strategy_recovery.py -v 2>&1",
      "description": "Verify tests still pass after ruff fixes"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:56:01.807658",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && ruff check /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_recoverable_strategy.py /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_indicator_warmup.py /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_exit_order_recreation.py && ruff format /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_recoverable_strategy.py /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_indicator_warmup.py /media/sam/1TB/nautilus_dev/tests/unit/recovery/test_exit_order_recreation.py 2>&1",
      "description": "Verify ruff passes after fixes"
    },
    {
      "operation": "bash",
      "timestamp": "2025-12-30T19:56:09.781412",
      "command": "source /media/sam/2TB-NVMe/prod/apps/nautilus_nightly/nautilus_nightly_env/bin/activate && python -m pytest tests/unit/recovery/test_recoverable_strategy.py tests/unit/recovery/test_indicator_warmup.py tests/unit/recovery/test_exit_order_recreation.py -v --tb=short 2>&1",
      "description": "Re-run tests after import cleanup"
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:56:10.225593",
      "todo_count": 6
    },
    {
      "operation": "todowrite",
      "timestamp": "2025-12-30T19:56:21.058169",
      "todo_count": 7
    },
    {
      "operation": "taskoutput",
      "timestamp": "2025-12-30T19:56:32.743363",
      "task_id": "a099a1c",
      "block": true,
      "timeout": 120000
    }
  ],
  "last_updated": "2025-12-30T19:56:32.743380"
}